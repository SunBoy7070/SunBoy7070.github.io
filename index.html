<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-w&#39;re&#39;r&#39;q&#39;er" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/08/w're'r'q'er/" class="article-date">
  <time datetime="2019-11-08T01:26:42.956Z" itemprop="datePublished">2019-11-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/08/w're'r'q'er/">w&#39;re&#39;r&#39;q&#39;er</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="w-39-re-39-r-39-q-39-er"><a href="#w-39-re-39-r-39-q-39-er" class="headerlink" title="w&#39;re&#39;r&#39;q&#39;er"></a>w&#39;re&#39;r&#39;q&#39;er</h1><ol>
<li>222</li>
<li>22</li>
</ol>
<ol start="3">
<li>2</li>
<li>2</li>
</ol>
<p>阿尔发顺丰啊发发啊奥沙发士大夫奥收到发生的奥沙暗室逢灯是滴a’s</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">MainWindow *pMainWindow = <span class="keyword">new</span> MainWindow();</span><br><span class="line">pMainWindow-&gt;setWindowTitle(QStringLiteral(<span class="string">"主界面"</span>));</span><br><span class="line">pMainWindow-&gt;show();</span><br><span class="line"></span><br><span class="line">CustomWindow *pDialog = <span class="keyword">new</span> CustomWindow(pMainWindow);</span><br><span class="line">pDialog-&gt;setWindowTitle(QStringLiteral(<span class="string">"模式对话框"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关键代码</span></span><br><span class="line">pDialog-&gt;exec();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭模态对话框以后才会执行下面的代码</span></span><br><span class="line">pMainWindow-&gt;setWindowTitle(QStringLiteral(<span class="string">"主界面-模式对话框"</span>));</span><br><span class="line">qDebug() &lt;&lt; QStringLiteral(<span class="string">"关闭模态对话框以后，可以继续向下执行"</span>);</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/578088/1573125475774-3f00d04b-cea7-4da7-a82e-70482f0e11e7.png#align=left&display=inline&height=314&name=20160117185134087.png&originHeight=314&originWidth=347&search=&size=9948&status=done&width=347" alt="20160117185134087.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/gif/578088/1573125523885-a0d0c9d9-1c33-4295-b91f-31adcdf56625.gif#align=left&display=inline&height=170&name=20160312160629449.gif&originHeight=170&originWidth=240&search=&size=3224&status=done&width=240" alt="20160312160629449.gif">)<img src="https://cdn.nlark.com/yuque/0/2019/gif/578088/1573125508844-eebc227f-7ea4-440a-8f0d-6dc58c8ca429.gif#align=left&display=inline&height=170&name=20160312155944187.gif&originHeight=170&originWidth=240&search=&size=2761&status=done&width=240" alt="20160312155944187.gif"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/11/08/w're'r'q'er/" data-id="ck2pgsnjk000238ue9hof9dv5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-heihie" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/04/heihie/" class="article-date">
  <time datetime="2019-11-04T13:49:19.000Z" itemprop="datePublished">2019-11-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/04/heihie/">heihie</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="/2019/11/04/heihie/1.png" alt="source/_posts/heihie"></p>
<p><strong><img src="/2019/11/04/heihie/1.png" class title="This is an test image"></strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/11/04/heihie/" data-id="ck2pgsnis000038uedmfk8yuc" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-linux系统编程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/03/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/" class="article-date">
  <time datetime="2019-11-03T13:07:12.298Z" itemprop="datePublished">2019-11-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/03/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/">linux系统编程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="linux系统编程"><a href="#linux系统编程" class="headerlink" title="linux系统编程"></a>linux系统编程</h1><p>[TOC]</p>
<h2 id="1-shell编程"><a href="#1-shell编程" class="headerlink" title="1 shell编程"></a>1 shell编程</h2><h3 id="1-1-shell概述"><a href="#1-1-shell概述" class="headerlink" title="1.1 shell概述"></a>1.1 shell概述</h3><p>shell的两层含义：<br>   既是一种应用程序,又是一种程序设计语言</p>
<h4 id="1-1-1-作为应用程序"><a href="#1-1-1-作为应用程序" class="headerlink" title="1.1.1 作为应用程序"></a>1.1.1 作为应用程序</h4><p>​       交互式地解释、执行用户输入的命令，将用户的操作翻译成机器可以识别的语言，完成相应功能</p>
<p>称之为shell命令解析器<br>shell是用户和Linux内核之间的接口程序<br>用户在提示符下输入的命令都由shell先解释然后传给Linux核心<br>它调用了系统核心的大部分功能来执行程序、并以并行的方式协调各个程序的运行<br>Linux系统中提供了好几种不同的shell命令解释器，如sh、ash、bash等。一般默认使用bash作为默认的解释器。我们后面编写的shell脚本，都是由上述shell命令解释器解释执行的。</p>
<p><img src="/2019/11/03/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/assets%5C1562148818086.png" alt="1562148818086"></p>
<p>shell是用户跟内核通信几种方式的一种</p>
<p><img src="/2019/11/03/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/assets%5C1562148843715.png" alt="1562148843715"></p>
<h4 id="1-1-2-作为程序设计语言"><a href="#1-1-2-作为程序设计语言" class="headerlink" title="1.1.2 作为程序设计语言"></a>1.1.2 作为程序设计语言</h4><p>它定义了各种变量和参数，并提供了许多在高级语言中才具有的控制结构，包括循环和分支<br>       完成类似于windows下批处理操作，简化我们对系统的管理与应用程序的部署</p>
<p>称之为shell脚本<br>我们学过的c/c++等语言，属于编译性语言（编写完成后需要使用编译器完成编译、汇编、链接等过程变为二进制代码方可执行）<br>shell脚本是一种脚本语言，我们只需使用任意文本编辑器，按照语法编写相应程序，增加可执行权限，即可在安装shell命令解释器的环境下执行<br>shell脚本主要用于：<br>帮助开发人员或系统管理员将复杂而又反复的操作放在一个文件中，通过简单的一步执行操作完成相应任务，从而解放他们的负担</p>
<p>shell应用举例：<br>1、《linux常用命令_练习.txt》<br>    我们前面完成了这个练习，步骤很多，其实我们只需要将所有操作写入一个文件——cmd.sh(名字跟后缀可任取，为了便于区分我们一般写为*.sh形式)<br>然后:<br>    chmod +x cmd.sh<br>    ./cmd.sh直接执行即可<br>2、假设我们要完成以下任务：<br>     判断用户家目录下（~）下面有没有一个叫test的文件夹<br>     如果没有，提示按y创建并进入此文件夹，按n退出<br>     如果有，直接进入，提示请输入一个字符串，并按此字符串创建一个文件，如果此文件已存在，提示重新输入，重复三次自动退出，不存在创建完毕，退出</p>
<p>简单的进行命令堆积无法完成以上任务，这就需要学习相应的shell脚本语法规则了</p>
<p>shell脚本大体可以分为两类：<br>系统进行调用<br>这类脚本无需用户调用，系统会在合适的时候调用，如：/etc/profile、~/.bashrc等</p>
<p>/etc/profile<br>    此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行，系统的公共环境变量在这里设置<br>        开始自启动的程序，一般也在这里设置<br>~/.bashrc<br>    用户自己的家目录中的.bashrc<br>    登录时会自动调用，打开任意终端时也会自动调用<br>    这个文件一般设置与个人用户有关的环境变量，如交叉编译器的路径等等</p>
<p>用户编写，需要手动调用的<br>例如我们上面编写的脚本都属于此类<br>无论是系统调用的还是需要我们自己调用的，其语法规则都一样</p>
<h3 id="1-2-shell语法"><a href="#1-2-shell语法" class="headerlink" title="1.2 shell语法"></a>1.2 shell语法</h3><h4 id="1-2-1-脚本的定义与执行"><a href="#1-2-1-脚本的定义与执行" class="headerlink" title="1.2.1 脚本的定义与执行"></a>1.2.1 脚本的定义与执行</h4><ol>
<li>定义以开头：#!/bin/sh <pre><code>#!用来声明脚本由什么shell解释，否则使用默认shell</code></pre></li>
<li>单个”#”号代表注释当前行</li>
<li>执行：<pre><code>chmod  +  x test.sh  ./test.sh  增加可执行权限后执行
   bash test.sh          直接指定使用bash解释test.sh
   . test.sh(source test.sh) 使用当前shell读取解释test.sh</code></pre></li>
</ol>
<p>三种执行脚本的方式不同点:<br>./和bash执行过程基本一致，后者明确指定bash解释器去执行脚本，脚本中#!指定的解释器不起作用<br>    前者首先检测#!，使用#!指定的shell，如果没有使用默认的shell<br>用./和bash去执行会在后台启动一个新的shell去执行脚本<br>  用.去执行脚本不会启动新的shell,直接由当前的shell去解释执行脚本。</p>
<p>例：1.sh</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">clear</span><br><span class="line">echo "this is the first shell script"</span><br></pre></td></tr></table></figure>

<p>注意：如果是在windows通过notepad++编辑脚本程序<br>需要用vi打开脚本，在最后一行模式下执行<br>:set  ff=unix</p>
<h4 id="1-2-2-变量"><a href="#1-2-2-变量" class="headerlink" title="1.2.2 变量"></a>1.2.2 变量</h4><ol>
<li><p>自定义变量</p>
<p>定义变量<br>变量名=变量值<br>如：num=10<br>引用变量<br>$变量名<br>如：i=$num   把变量num的值付给变量i<br>显示变量<br>使用echo命令可以显示单个变量取值<br>echo  $num<br>清除变量<br>使用unset命令清除变量<br>unset  varname</p>
<p>变量的其它用法：<br>read string</p>
<pre><code>从键盘输入一个字符串付给变量string</code></pre><p>readonly var=100</p>
<pre><code>定义一个只读变量,只能在定义时初始化,以后不能改变,不能被清除。</code></pre><p>export var=300</p>
<pre><code>使用export说明的变量，会被导出为环境变量，其它shell均可使用</code></pre><p>  注意：此时必须使用source 2_var.sh才可以生效</p>
<p>注意事项：<br>1 变量名只能包含英文字母下划线，不能以数字开头</p>
<pre><code>1_num=10  错误
num_1=20  正确 </code></pre><p>2 等号两边不能直接接空格符，若变量中本身就包含了空格，则整个字符串都要用双引号、或单引号括起来；双引号内的特殊字符可以保有变量特性，但是单引号内的特殊字符则仅为一般字符。</p>
<pre><code>name=aa bb             //错误
name=&quot;aa bb&quot;            //正确
echo &quot;$name is me&quot;         //输出：aa bb is me
echo &apos;$name is me&apos;        //输出：$name is me</code></pre><p>例2:  2_var.sh</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo "this is the var test shell script "</span><br><span class="line">name="edu"</span><br><span class="line">echo "$name is me"</span><br><span class="line">echo '$name is me'</span><br><span class="line"></span><br><span class="line">echo "please input a string"</span><br><span class="line">read string </span><br><span class="line">echo "the string of your input is $string"</span><br><span class="line"></span><br><span class="line">readonly var=1000</span><br><span class="line"><span class="meta">#</span><span class="bash">var=200</span></span><br><span class="line"></span><br><span class="line">export public_var=300</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p><strong>环境变量</strong></p>
<p>shell在开始执行时就已经定义了一些和系统的工作环境有关的变量，我们在shell中可以直接使用$name引用<br>定义：</p>
<pre><code>一般在~/.bashrc或/etc/profile文件中（系统自动调用的脚本）使用export设置，允许用户后来更改
VARNAME=value ；export VARNAME</code></pre><p>传统上，所有环境变量均为大写<br>显示环境变量</p>
<pre><code>使用env 命令可以查看所有的环境变量。</code></pre><p>清除环境变量</p>
<pre><code>使用unset 命令清除环境变量</code></pre><p>常见环境变量：<br>HOME：用于保存注册目录的完全路径名。<br>PATH：用于保存用冒号分隔的目录路径名，shell将按PATH变量中给出的顺序搜索这些目录，找到的第一个与命令名称一致的可执行文件将被执行。<br>  PATH=$HOME/bin:/bin:/usr/bin;export PATH<br>HOSTNAME：主机名<br>SHELL：默认的shell命令解析器<br>LOGNAME：此变量保存登录名<br>PWD：当前工作目录的绝对路径名<br>……</p>
<p>例：3_export.sh</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo "You are welcome to use bash"</span><br><span class="line">echo "Current work dirctory is $PWD"</span><br><span class="line">echo "the host name is  $HOSTNAME"</span><br><span class="line">echo "your home dir  $HOME"</span><br><span class="line">echo "Your shell is  $SHELL"</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>预设变量$#：传给shell脚本参数的数量<br>$*：传给shell脚本参数的内容<br>$1、$2、$3、…、$9：运行脚本时传递给其的参数，用空格隔开<br>$?：命令执行后返回的状态<br>“$?”用于检查上一个命令执行是否正确(在Linux中，命令退出状态为0表示该命令正确执行，任何非0值表示命令出错)。<br>$0：当前执行的进程名<br>$$：当前进程的进程号<br>“$$”变量最常见的用途是用作临时文件的名字以保证临时文件不会重复</p>
<p>例：4_$.sh</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo "your shell script name is $0"</span><br><span class="line">echo "the params of your input is $*"</span><br><span class="line">echo "the num of your input  params is $#"</span><br><span class="line">echo "the params is $1 $2 $3 $4"</span><br><span class="line"></span><br><span class="line">ls</span><br><span class="line">echo "the cmd state is $?"</span><br><span class="line">cd /root</span><br><span class="line">echo "the cmd state is $?"</span><br><span class="line"></span><br><span class="line">echo "process id is $$"</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li><p>脚本变量的特殊用法：”” `` ‘ \ () {}</p>
<p>“”（双引号）：包含的变量会被解释<br>‘’（单引号）：包含的变量会当做字符串解释<br>``(数字键1左面的反引号)：反引号中的内容作为系统命令，并执行其内容，可以替换输出为一个变量<br>$ echo “today is <code>date</code> “<br>today is 2012年07月29日星期日 12:55:21 CST<br>\ 转义字符：</p>
<pre><code>同c语言 \n \t \r \a等 echo命令需加-e转义</code></pre><p>(命令序列)：</p>
<pre><code>由子shell来完成,不影响当前shell中的变量</code></pre><p>{ 命令序列 }：</p>
<pre><code>在当前shell中执行，会影响当前变量</code></pre><p>例：5_var_spe.sh  注意： “{”、“}”前后有一空格</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">name=teacher</span><br><span class="line">string1="good moring $name"</span><br><span class="line">string2='good moring $name'</span><br><span class="line">echo $string1</span><br><span class="line">echo $string2</span><br><span class="line"></span><br><span class="line">echo "today is `date`  "</span><br><span class="line">echo 'today is `date`  '</span><br><span class="line"></span><br><span class="line">echo -e "this \n is\ta\ntest"</span><br><span class="line"></span><br><span class="line">( name=student;echo "1 $name" )</span><br><span class="line">echo 1:$name</span><br><span class="line">&#123; name=student; echo "2 $name"; &#125;</span><br><span class="line">echo 2:$name</span><br></pre></td></tr></table></figure>




</li>
</ol>
<h4 id="1-2-3-条件测试语句"><a href="#1-2-3-条件测试语句" class="headerlink" title="1.2.3 条件测试语句"></a>1.2.3 条件测试语句</h4><p>在写shell脚本时，经常遇到的问题就是判断字符串是否相等，可能还要检查文件状态或进行数字测试，只有这些测试完成才能做下一步动作<br>test命令：用于测试字符串、文件状态和数字<br>test命令有两种格式:<br>    test condition  或[ condition ]<br>    使用方括号时，要注意在条件两边加上空格<br>shell脚本中的条件测试如下：<br>文件测试、字符串测试、数字测试、复合测试<br>测试语句一般与后面讲的条件语句联合使用</p>
<ol>
<li><p>文件</p>
<p>文件测试：测试文件状态的条件表达式<br>   -e 是否存在    -d 是目录        -f 是文件<br>   -r 可读        -w 可写            -x 可执行<br>   -L 符号连接    -c是否字符设备    -b是否块设备<br>   -s 文件非空<br>例：6_test_file.sh</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">test -e /dev/qaz</span><br><span class="line">echo $?</span><br><span class="line"></span><br><span class="line">test -e /home</span><br><span class="line">echo $?</span><br><span class="line"></span><br><span class="line">test -d /home</span><br><span class="line">echo $?</span><br><span class="line"></span><br><span class="line">test -f /home</span><br><span class="line">echo $?</span><br><span class="line"></span><br><span class="line">mkdir test_sh</span><br><span class="line">chmod 500 test_sh</span><br><span class="line"></span><br><span class="line">[ -r test_sh ]</span><br><span class="line">echo $?</span><br><span class="line"></span><br><span class="line">[ -w test_sh ]</span><br><span class="line">echo $?</span><br><span class="line"></span><br><span class="line">[ -x test_sh ]</span><br><span class="line">echo $?</span><br><span class="line"></span><br><span class="line">[ -s test_sh ]</span><br><span class="line">echo $?</span><br><span class="line"></span><br><span class="line">[ -c /dev/console ]</span><br><span class="line">echo $?</span><br><span class="line">[ -b /dev/sda ]</span><br><span class="line">echo $?</span><br><span class="line">[ -L /dev/stdin ]</span><br><span class="line">echo $?</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>字符串</p>
<p>字符串测试<br>test str_operator “str”</p>
<pre><code>test “str1” str_operator “str2”
[ str_operator “str” ]
[ “str1” str_operator “str2”]</code></pre><p>其中str_operator可以是:</p>
<pre><code>= 两个字符串相等   != 两个字符串不相等
-z 空串            -n 非空串</code></pre><p>例：7_test_string.sh</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">test -z $yn</span><br><span class="line">echo $?</span><br><span class="line"></span><br><span class="line">echo "please input a y/n"</span><br><span class="line">read yn</span><br><span class="line">[ -z "$yn" ]</span><br><span class="line">echo 1:$?</span><br><span class="line"></span><br><span class="line">[ $yn = "y" ]</span><br><span class="line">echo 2:$?</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>数字</p>
<p>测试数值格式如下:</p>
<pre><code>test num1 num_operator num2
[ num1 num_operator num2 ]</code></pre><p>num_operator可以是:</p>
<pre><code>-eq 数值相等   
-ne 数值不相等
-gt 数1大于数2       
-ge 数1大于等于数2
-le 数1小于等于数2
-lt 数1小于数2</code></pre><p><img src="/2019/11/03/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/assets%5C1562150743753.png" alt="1562150743753"></p>
<p>例：8_test_num.sh</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo "please input a num(1-9)"</span><br><span class="line">read num</span><br><span class="line">[ $num -eq 5 ]</span><br><span class="line">echo $?</span><br><span class="line">[ $num -ne 5 ]</span><br><span class="line">echo $?</span><br><span class="line">[ $num -gt 5 ]</span><br><span class="line">echo $?</span><br><span class="line">[ $num -ge 5 ]</span><br><span class="line">echo $?</span><br><span class="line">[ $num -le 5 ]</span><br><span class="line">echo $?</span><br><span class="line">[ $num -lt 5 ]</span><br><span class="line">echo $?</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li><p>复合测试</p>
<p>命令执行控制:<br>&amp;&amp;：<br>command1 &amp;&amp; command2<br>   &amp;&amp;左边命令（command1）执行成功(即返回0）shell才执行&amp;&amp;右边的命令（command2）<br>||</p>
<pre><code>command1 || command2</code></pre><p>  ||左边的命令（command1）未执行成功(即返回非0）shell才执行||右边的命令（command2）<br>例：<br>test -e /home &amp;&amp; test -d /home &amp;&amp; echo “true”<br>test 2 -lt 3 &amp;&amp; test 5 -gt 3 &amp;&amp; echo “equal”<br>test “aaa” = “aaa” || echo “not equal” &amp;&amp; echo “equal”</p>
<p>多重条件判定</p>
<p><img src="/2019/11/03/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/assets%5C1562150869413.png" alt="1562150869413"></p>
</li>
</ol>
<h4 id="1-2-3-控制语句"><a href="#1-2-3-控制语句" class="headerlink" title="1.2.3 控制语句"></a>1.2.3 控制语句</h4><ol>
<li><p>if控制语句格式一：<br>if [条件1]; then</p>
<pre><code>执行第一段程序 </code></pre><p>else</p>
<pre><code>执行第二段程序 </code></pre><p>fi<br>格式二：<br>if [条件1]; then</p>
<pre><code>执行第一段程序 </code></pre><p>elif [条件2]；then</p>
<pre><code>执行第二段程序</code></pre><p>else</p>
<pre><code>执行第三段程序 </code></pre><p>fi</p>
<p>例：9_if_then.sh</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo "Press y to continue"</span><br><span class="line">read yn</span><br><span class="line">if [ $yn = "y" ]; then</span><br><span class="line">	echo "script is running..."</span><br><span class="line">else</span><br><span class="line">	echo "stopped!"</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>case控制语句</p>
<p>case $变量名称 in</p>
<pre><code>“第一个变量内容”) 
   程序段一 
   ;; 
“第二个变量内容”) 
   程序段二 
   ;; 
*) 
   其它程序段 
   exit 1 </code></pre><p>  esac </p>
<p>例：10_case1.sh</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo "This script will print your choice"</span><br><span class="line"></span><br><span class="line">case "$1" in</span><br><span class="line">	"one")</span><br><span class="line">		echo "your choice is one"</span><br><span class="line">		;;</span><br><span class="line">	"two")</span><br><span class="line">		echo "your choice is two"</span><br><span class="line">		;;</span><br><span class="line">	"three")</span><br><span class="line">		echo "Your choice is three"</span><br><span class="line">		;;</span><br><span class="line">	*)</span><br><span class="line">		echo "Error Please try again!"</span><br><span class="line">		exit 1</span><br><span class="line">		;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>

<p>例：10_case2.sh</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">echo "Please input your choice:"</span><br><span class="line">read choice</span><br><span class="line"></span><br><span class="line">case "$choice" in</span><br><span class="line">	Y | yes | Yes | YES)</span><br><span class="line">	echo "It's right"</span><br><span class="line">	;;</span><br><span class="line">	N* | n*)</span><br><span class="line">	echo "It's wrong"</span><br><span class="line">	;;</span><br><span class="line">	*)</span><br><span class="line">	exit 1</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>for控制语句</p>
<p>形式一：<br>for (( 初始值; 限制值; 执行步阶 ))</p>
<pre><code>do 
    程序段
done </code></pre><p>初始值：变量在循环中的起始值<br>限制值：当变量值在这个限制范围内时，就继续进行循环<br>执行步阶：每作一次循环时，变量的变化量</p>
<p>declare是bash的一个内建命令，可以用来声明shell变量、设置变量的属性。declare也可以写作typeset。<br>declare -i s 代表强制把s变量当做int型参数运算。</p>
<p>例：11_for1.sh</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">declare -i sum</span><br><span class="line">for (( i=1; i&lt;=100; i=i+1 ))</span><br><span class="line">do</span><br><span class="line">	sum=sum+i</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo "The result is $sum"</span><br></pre></td></tr></table></figure>

<p>形式二：<br>for var in con1 con2 con3 …</p>
<pre><code>do
    程序段
done </code></pre><p>第一次循环时，$var的内容为con1<br>第二次循环时，$var的内容为con2<br>第三次循环时，$var的内容为con3<br>……</p>
<p>例：11_for2.sh</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">for i in 1 2 3 4 5 6 7 8 9</span><br><span class="line">do</span><br><span class="line">	echo $i</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">例：11_for3.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">for name in `ls`</span><br><span class="line">do</span><br><span class="line">if [ -f $name ];then</span><br><span class="line">	echo "$name is file"</span><br><span class="line">elif [ -d $name ];then</span><br><span class="line">	echo "$name is directory"</span><br><span class="line">else</span><br><span class="line">	echo "^_^"</span><br><span class="line">fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li><p>while控制语句</p>
<p>while [ condition ]</p>
<pre><code>do 
    程序段
done</code></pre><p>当condition成立的时候进入while循环，直到condition不成立时才退出循环。</p>
<p>例：12_while.sh</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">declare -i i</span><br><span class="line">declare -i s</span><br><span class="line">while [ "$i" != "101" ]</span><br><span class="line">do</span><br><span class="line">	s+=i;</span><br><span class="line">	i=i+1;</span><br><span class="line">done</span><br><span class="line">echo "The count is $s"</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="5">
<li><p>unitl控制语句</p>
<p>until [ condition ]</p>
<pre><code>do
    程序段
done</code></pre><p>这种方式与while恰恰相反，当condition成立的时候退出循环，否则继续循环。</p>
<p>例：13_until.sh</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">declare -i i</span><br><span class="line">declare -i s</span><br><span class="line">until [ "$i" = "101" ]</span><br><span class="line">do</span><br><span class="line">	s+=i;</span><br><span class="line">	i=i+1;</span><br><span class="line">done</span><br><span class="line">echo "The count is $s"</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="6">
<li><p>break continue控制语句</p>
<p>break<br>break命令允许跳出循环。<br>break 通常在进行一些处理后退出循环或case 语句<br>continue<br>continue 命令类似于break 命令<br>只有一点重要差别，它不会跳出循环，只是跳过这个循环步</p>
</li>
</ol>
<h4 id="1-2-4-函数"><a href="#1-2-4-函数" class="headerlink" title="1.2.4 函数"></a>1.2.4 函数</h4><p>有些脚本段间互相重复，如果能只写一次代码块而在任何地方都能引用那就提高了代码的可重用性。<br>shell允许将一组命令集或语句形成一个可用块，这些块称为shell函数。<br>定义函数的两种格式：<br>格式一：<br>函数名（） {<br>  命令  …<br>}<br>格式二：<br>function 函数名（） {<br>  命令  …<br>}</p>
<p>函数可以放在同一个文件中作为一段代码，也可以放在只包含函数的单独文件中<br>所有函数在使用前必须定义，必须将函数放在脚本开始部分，直至shell解释器首次发现它时，才可以使用<br>调用函数的格式为：<br>　　函数名 param1 param2……<br>使用参数同在一般脚本中使用特殊变量<br>          $1，$2 …$9一样<br>函数可以使用return 提前结束并带回返回值<br>    return 从函数中返回，用最后状态命令决定返回值。<br>    return 0 无错误返回<br>    return 1 有错误返回<br>例：14_function.sh</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">is_it_directory()</span><br><span class="line">&#123;</span><br><span class="line">	if [ $# -lt 1 ]; then</span><br><span class="line">		echo "I need an argument"</span><br><span class="line">		return 1</span><br><span class="line">	fi</span><br><span class="line">	if [ ! -d $1 ]; then</span><br><span class="line">		return 2</span><br><span class="line">	else</span><br><span class="line">		return 3</span><br><span class="line">	fi</span><br><span class="line">&#125;</span><br><span class="line">echo -n "enter destination directory:"</span><br><span class="line">read direct</span><br><span class="line">is_it_directory $direct</span><br><span class="line">echo "the result is $?"</span><br></pre></td></tr></table></figure>



<h2 id="2-linux文件IO操作"><a href="#2-linux文件IO操作" class="headerlink" title="2 linux文件IO操作"></a>2 linux文件IO操作</h2><h3 id="2-1-系统调用"><a href="#2-1-系统调用" class="headerlink" title="2.1 系统调用"></a>2.1 系统调用</h3><p>系统调用，顾名思义，说的是操作系统提供给用户程序调用的一组“特殊”接口。用户程序可以通过这组“特殊”接口来获得操作系统内核提供的服务，比如用户可以通过文件系统相关的调用请求系统打开文件、关闭文件或读写文件，可以通过时钟相关的系统调用获得系统时间或设置定时器等。</p>
<p>从逻辑上来说，系统调用可被看成是一个内核与用户空间程序交互的接口——它好比一个中间人，把用户进程的请求传达给内核，待内核把请求处理完毕后再将处理结果送回给用户空间。</p>
<p><img src="/2019/11/03/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/assets%5C1562151884513.png" alt="1562151884513"></p>
<p>系统服务之所以需要通过系统调用来提供给用户空间的根本原因是为了对系统进行“保护”，因为我们知道 Linux 的运行空间分为内核空间与用户空间，它们各自运行在不同的级别中，逻辑上相互隔离。</p>
<p>所以用户进程在通常情况下不允许访问内核数据，也无法使用内核函数，它们只能在用户空间操作用户数据，调用用户空间函数。</p>
<p>比如我们熟悉的“hello world”程序（执行时）就是标准的用户空间进程，它使用的打印函数 printf 就属于用户空间函数，打印的字符“hello word”字符串也属于用户空间数据。</p>
<p>但是很多情况下，用户进程需要获得系统服务（调用系统程序），这时就必须利用系统提供给用户的“特殊接口”——系统调用了，它的特殊性主要在于规定了用户进程进入内核的具体位置。</p>
<p>换句话说，用户访问内核的路径是事先规定好的，只能从规定位置进入内核，而不准许肆意跳入内核。有了这样的陷入内核的统一访问路径限制才能保证内核安全无误。我们可以形象地描述这种机制：作为一个游客，你可以买票要求进入野生动物园，但你必须老老实实地坐在观光车上，按照规定的路线观光游览。当然，不准下车，因为那样太危险，不是让你丢掉小命，就是让你吓坏了野生动物。</p>
<p>系统调用是属于操作系统内核的一部分的，必须以某种方式提供给进程让它们去调用。CPU 可以在不同的特权级别下运行，而相应的操作系统也有不同的运行级别，用户态和内核态。运行在内核态的进程可以毫无限制的访问各种资源，而在用户态下的用户进程的各种操作都有着限制，比如不能随意的访问内存、不能开闭中断以及切换运行的特权级别。显然，属于内核的系统调用一定是运行在内核态下，但是如何切换到内核态呢？</p>
<p>答案是软件中断。软件中断和我们常说的中断（硬件中断）不同之处在于，它是通过软件指令触发而并非外设引发的中断，也就是说，又是编程人员开发出的一种异常（该异常为正常的异常）。操作系统一般是通过软件中断从用户态切换到内核态</p>
<p><strong>系统调用和库函数的区别</strong></p>
<p>Linux 下对文件操作有两种方式：系统调用（system call）和库函数调用（Library functions）。</p>
<p>库函数由两类函数组成：</p>
<p>1 不需要调用系统调用</p>
<p>不需要切换到内核空间即可完成函数全部功能，并且将结果反馈给应用程序，如strcpy、bzero 等字符串操作函数。</p>
<p>2 需要调用系统调用</p>
<p>需要切换到内核空间，这类函数通过封装系统调用去实现相应功能，如 printf、fread等。</p>
<p><img src="/2019/11/03/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/assets%5C1562152005010.png" alt="1562152005010"></p>
<p>系统调用是需要时间的，程序中频繁的使用系统调用会降低程序的运行效率。当运行内核代码时，CPU工作在内核态，在系统调用发生前需要保存用户态的栈和内存环境，然后转入内核态工作。系统调用结束后，又要切换回用户态。这种环境的切换会消耗掉许多时间 。</p>
<p><strong>C库中IO函数工作流程</strong></p>
<p><img src="/2019/11/03/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/assets%5C1562152180783.png" alt="1562152180783"></p>
<p>库函数访问文件的时候根据需要，设置不同类型的缓冲区，从而减少了直接调用 IO 系统调用的次数，提高了访问效率。</p>
<p>这个过程类似于快递员给某个区域（内核空间）送快递一样，快递员有两种方式送：</p>
<p>1）来一件快递就马上送到目的地，来一件送一件，这样导致来回走比较频繁（系统调用）</p>
<p>2）等快递攒着差不多后（缓冲区），才一次性送到目的地（库函数调用）</p>
<h3 id="2-2-文件描述符"><a href="#2-2-文件描述符" class="headerlink" title="2.2 文件描述符"></a>2.2 文件描述符</h3><p>在 Linux 的世界里，一切设备皆文件。我们可以系统调用中 I/O 的函数（I：input，输入；O：output，输出），对文件进行相应的操作（ open()、close()、write() 、read() 等）。</p>
<p>打开现存文件或新建文件时，系统（内核）会返回一个文件描述符，文件描述符用来指定已打开的文件。这个文件描述符相当于这个已打开文件的标号，文件描述符是非负整数，是文件的标识，操作这个文件描述符相当于操作这个描述符所指定的文件。</p>
<p>程序运行起来后（每个进程）都有一张文件描述符的表，标准输入、标准输出、标准错误输出设备文件被打开，对应的文件描述符 0、1、2 记录在表中。程序运行起来后这三个文件描述符是默认打开的。</p>
<p><img src="/2019/11/03/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/assets%5C1562152275223.png" alt="1562152275223"></p>
<p>在程序运行起来后打开其他文件时，系统会返回文件描述符表中最小可用的文件描述符，并将此文件描述符记录在表中。</p>
<p><img src="/2019/11/03/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/assets%5C1562152335696.png" alt="1562152335696"></p>
<p><strong>最大打开的文件个数</strong></p>
<p>Linux 中一个进程最多只能打开 NR_OPEN_DEFAULT （即1024）个文件，故当文件不再使用时应及时调用 close() 函数关闭文件。</p>
<p>查看当前系统允许打开最大文件个数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/fs/file-<span class="built_in">max</span></span><br></pre></td></tr></table></figure>


<p>当前默认设置最大打开文件个数1024</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -a</span><br></pre></td></tr></table></figure>


<p>修改默认设置最大打开文件个数为4096</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -n <span class="number">4096</span></span><br></pre></td></tr></table></figure>



<h3 id="2-3-文件打开读写关闭"><a href="#2-3-文件打开读写关闭" class="headerlink" title="2.3 文件打开读写关闭"></a>2.3 文件打开读写关闭</h3><h4 id="2-3-1-打开文件open"><a href="#2-3-1-打开文件open" class="headerlink" title="2.3.1 打开文件open"></a>2.3.1 打开文件open</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line">功能：</span><br><span class="line">    打开文件，如果文件不存在则可以选择创建。</span><br><span class="line">参数：</span><br><span class="line">    pathname：文件的路径及文件名</span><br><span class="line">    flags：打开文件的行为标志，必选项 O_RDONLY, O_WRONLY, O_RDWR</span><br><span class="line">    mode：这个参数，只有在文件不存在时有效，指新建文件时指定文件的权限</span><br><span class="line">返回值：</span><br><span class="line">    成功：成功返回打开的文件描述符</span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>flags详细说明</p>
<p>必选项：</p>
<table>
<thead>
<tr>
<th align="left"><strong>取值</strong></th>
<th align="left"><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">O_RDONLY</td>
<td align="left">以只读的方式打开</td>
</tr>
<tr>
<td align="left">O_WRONLY</td>
<td align="left">以只写的方式打开</td>
</tr>
<tr>
<td align="left">O_RDWR</td>
<td align="left">以可读、可写的方式打开</td>
</tr>
</tbody></table>
<p>可选项，和必选项按位或起来</p>
<table>
<thead>
<tr>
<th align="left"><strong>取值</strong></th>
<th align="left"><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">O_CREAT</td>
<td align="left">文件不存在则创建文件，使用此选项时需使用mode说明文件的权限</td>
</tr>
<tr>
<td align="left">O_EXCL</td>
<td align="left">如果同时指定了O_CREAT，且文件已经存在，则出错</td>
</tr>
<tr>
<td align="left">O_TRUNC</td>
<td align="left">如果文件存在，则清空文件内容</td>
</tr>
<tr>
<td align="left">O_APPEND</td>
<td align="left">写文件时，数据添加到文件末尾</td>
</tr>
<tr>
<td align="left">O_NONBLOCK</td>
<td align="left">对于设备文件, 以O_NONBLOCK方式打开可以做非阻塞I/O</td>
</tr>
</tbody></table>
<p>mode补充说明</p>
<p>1) 文件最终权限：mode &amp; ~umask</p>
<p>2) shell进程的umask掩码可以用umask命令查看</p>
<p> umask：查看掩码（补码）</p>
<p> umask mode：设置掩码，mode为八进制数</p>
<p> umask -S：查看各组用户的默认操作权限</p>
<table>
<thead>
<tr>
<th align="left"><strong>取值</strong></th>
<th align="left"><strong>八进制</strong></th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">S_IRWXU</td>
<td align="left">00700</td>
<td align="left">文件所有者的读、写、可执行权限</td>
</tr>
<tr>
<td align="left">S_IRUSR</td>
<td align="left">00400</td>
<td align="left">文件所有者的读权限</td>
</tr>
<tr>
<td align="left">S_IWUSR</td>
<td align="left">00200</td>
<td align="left">文件所有者的写权限</td>
</tr>
<tr>
<td align="left">S_IXUSR</td>
<td align="left">00100</td>
<td align="left">文件所有者的可执行权限</td>
</tr>
<tr>
<td align="left">S_IRWXG</td>
<td align="left">00070</td>
<td align="left">文件所有者同组用户的读、写、可执行权限</td>
</tr>
<tr>
<td align="left">S_IRGRP</td>
<td align="left">00040</td>
<td align="left">文件所有者同组用户的读权限</td>
</tr>
<tr>
<td align="left">S_IWGRP</td>
<td align="left">00020</td>
<td align="left">文件所有者同组用户的写权限</td>
</tr>
<tr>
<td align="left">S_IXGRP</td>
<td align="left">00010</td>
<td align="left">文件所有者同组用户的可执行权限</td>
</tr>
<tr>
<td align="left">S_IRWXO</td>
<td align="left">00007</td>
<td align="left">其他组用户的读、写、可执行权限</td>
</tr>
<tr>
<td align="left">S_IROTH</td>
<td align="left">00004</td>
<td align="left">其他组用户的读权限</td>
</tr>
<tr>
<td align="left">S_IWOTH</td>
<td align="left">00002</td>
<td align="left">其他组用户的写权限</td>
</tr>
<tr>
<td align="left">S_IXOTH</td>
<td align="left">00001</td>
<td align="left">其他组用户的可执行权限</td>
</tr>
</tbody></table>
<h4 id="2-3-2-关闭文件close"><a href="#2-3-2-关闭文件close" class="headerlink" title="2.3.2 关闭文件close"></a>2.3.2 关闭文件close</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line">功能：</span><br><span class="line">    关闭已打开的文件</span><br><span class="line">参数：</span><br><span class="line">    fd : 文件描述符，<span class="built_in">open</span>()的返回值</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败： <span class="number">-1</span>, 并设置errno</span><br></pre></td></tr></table></figure>



<h4 id="2-3-3-向文件写数据write"><a href="#2-3-3-向文件写数据write" class="headerlink" title="2.3.3 向文件写数据write"></a>2.3.3 向文件写数据write</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">ssize_t</span> <span class="built_in">write</span>(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br><span class="line">功能：</span><br><span class="line">    把指定数目的数据写到文件（fd）</span><br><span class="line">参数：</span><br><span class="line">    fd :  文件描述符</span><br><span class="line">    buf : 数据首地址</span><br><span class="line">    count : 写入数据的长度（字节）</span><br><span class="line">返回值：</span><br><span class="line">    成功：实际写入数据的字节个数</span><br><span class="line">    失败： - <span class="number">1</span></span><br></pre></td></tr></table></figure>



<h4 id="2-3-4-从文件读数据read"><a href="#2-3-4-从文件读数据read" class="headerlink" title="2.3.4 从文件读数据read"></a>2.3.4 从文件读数据read</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &lt;unistd.h</span></span><br><span class="line"><span class="keyword">ssize_t</span> <span class="built_in">read</span>(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br><span class="line">功能：</span><br><span class="line">    把指定数目的数据读到内存（缓冲区）</span><br><span class="line">参数：</span><br><span class="line">    fd : 文件描述符</span><br><span class="line">    buf : 内存首地址</span><br><span class="line">    count : 读取的字节个数</span><br><span class="line">返回值：</span><br><span class="line">    成功：实际读取到的字节个数</span><br><span class="line">    失败： - <span class="number">1</span></span><br></pre></td></tr></table></figure>



<h3 id="2-4-文件的阻塞特性"><a href="#2-4-文件的阻塞特性" class="headerlink" title="2.4 文件的阻塞特性"></a>2.4 文件的阻塞特性</h3><p>​        对于一些设备文件读写操作,如管道,套接字,标准设备文件,默认缓冲区没有数据读会带阻塞,默认缓存区满的状</p>
<p>​        态,写也会阻塞.</p>
<p>​        如果从终端输入的数据没有换行符，默认调用read读终端设备就会阻塞，如果网络上没有接收到数据包，调        用read从网络读就会阻塞，至于会阻塞多长时间也是不确定的，如果一直没有数据到达就一直阻塞在那里。</p>
<p>​        同样，写常规文件是不会阻塞的，而向终端设备或网络写则不一定。</p>
<p>​        【注意】阻塞与非阻塞是对于文件而言的，而不是指read、write等的属性。</p>
<p>​        以非阻塞方式打开文件程序示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; //read</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt; //EAGAIN</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// /dev/tty --&gt; 当前终端设备</span></span><br><span class="line">    <span class="comment">// 以不阻塞方式(O_NONBLOCK)打开终端设备</span></span><br><span class="line">    <span class="keyword">int</span> fd = <span class="built_in">open</span>(<span class="string">"/dev/tty"</span>, O_RDONLY | O_NONBLOCK);</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    n = <span class="built_in">read</span>(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果为非阻塞，但是没有数据可读，此时全局变量 errno 被设置为 EAGAIN</span></span><br><span class="line">        <span class="keyword">if</span> (errno != EAGAIN)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"read /dev/tty"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"没有数据\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们还可以通过fcntl函数来设置文件描述符的阻塞特性</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ... <span class="comment">/* arg */</span>)</span></span>;</span><br><span class="line">功能：改变已打开的文件性质，fcntl针对描述符提供控制。</span><br><span class="line">参数：</span><br><span class="line">    fd：操作的文件描述符</span><br><span class="line">    cmd：操作方式</span><br><span class="line">    arg：针对cmd的值，fcntl能够接受第三个参数<span class="keyword">int</span> arg。</span><br><span class="line">返回值：</span><br><span class="line">    成功：返回某个其他值</span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>fcntl函数有5种功能：</p>
<p>1)     复制一个现有的描述符（cmd=F_DUPFD）</p>
<p>2)     获得／设置文件描述符标记(cmd=F_GETFD或F_SETFD)</p>
<p><strong>3)     获得／设置文件状态标记(cmd=F_GETFL或F_SETFL)</strong></p>
<p>4)     获得／设置异步I/O所有权(cmd=F_GETOWN或F_SETOWN)</p>
<p>5)     获得／设置记录锁(cmd=F_GETLK, F_SETLK或F_SETLKW)</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">1024</span>]=<span class="string">""</span>;</span><br><span class="line">	<span class="built_in">read</span>(STDIN_FILENO,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"buf=%s\n"</span>,buf);</span><br><span class="line">	<span class="comment">//设置STDIN_FILENO为非阻塞</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 获取标志位</span></span><br><span class="line">	<span class="keyword">int</span> flag = fcntl(STDIN_FILENO,F_GETFL);</span><br><span class="line">	<span class="comment">//改变标志</span></span><br><span class="line">	flag |= O_NONBLOCK;</span><br><span class="line">    <span class="comment">//给文件描述符设置非阻塞标志</span></span><br><span class="line">	fcntl(STDIN_FILENO,F_SETFL,flag);</span><br><span class="line">	<span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">	<span class="built_in">read</span>(STDIN_FILENO,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"buf=%s\n"</span>,buf);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-5-获取文件状态信息"><a href="#2-5-获取文件状态信息" class="headerlink" title="2.5 获取文件状态信息"></a>2.5 获取文件状态信息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, struct stat *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lstat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, struct stat *buf)</span></span>;</span><br><span class="line">功能：</span><br><span class="line">    获取文件状态信息</span><br><span class="line">    stat和lstat的区别：</span><br><span class="line">        当文件是一个符号链接时，lstat返回的是该符号链接本身的信息；</span><br><span class="line">        而stat返回的是该链接指向的文件的信息。</span><br><span class="line">参数：</span><br><span class="line">    path：文件名</span><br><span class="line">    buf：保存文件信息的结构体</span><br><span class="line">返回值：</span><br><span class="line">    成功： <span class="number">0</span></span><br><span class="line">    失败: <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>struct stat结构体说明： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">    <span class="keyword">dev_t</span>           st_dev;     <span class="comment">//文件的设备编号</span></span><br><span class="line">    <span class="keyword">ino_t</span>           st_ino;     <span class="comment">//节点</span></span><br><span class="line">    <span class="keyword">mode_t</span>          st_mode;            <span class="comment">//文件的类型和存取的权限</span></span><br><span class="line">    <span class="keyword">nlink_t</span>         st_nlink;       <span class="comment">//连到该文件的硬连接数目，刚建立的文件值为1</span></span><br><span class="line">    <span class="keyword">uid_t</span>           st_uid;     <span class="comment">//用户ID</span></span><br><span class="line">    <span class="keyword">gid_t</span>           st_gid;     <span class="comment">//组ID</span></span><br><span class="line">    <span class="keyword">dev_t</span>           st_rdev;        <span class="comment">//(设备类型)若此文件为设备文件，则为其设备编号</span></span><br><span class="line">    <span class="keyword">off_t</span>           st_size;        <span class="comment">//文件字节数(文件大小)</span></span><br><span class="line">    <span class="keyword">blksize_t</span>       st_blksize;     <span class="comment">//块大小(文件系统的I/O 缓冲区大小)</span></span><br><span class="line">    <span class="keyword">blkcnt_t</span>        st_blocks;      <span class="comment">//块数</span></span><br><span class="line">    <span class="keyword">time_t</span>          st_atime;       <span class="comment">//最后一次访问时间</span></span><br><span class="line">    <span class="keyword">time_t</span>          st_mtime;       <span class="comment">//最后一次修改时间</span></span><br><span class="line">    <span class="keyword">time_t</span>          st_ctime;       <span class="comment">//最后一次改变时间(指属性)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>st_mode(16位整数)参数说明 :</p>
<p><img src="/2019/11/03/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/assets%5C1562211276422.png" alt="1562211276422"></p>
<p>判断文件类型:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">buf</span>;</span></span><br><span class="line">    stat(<span class="string">"a.txt"</span>, &amp;buf);</span><br><span class="line">    <span class="keyword">if</span> (S_ISREG(buf.st_mode))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="string">"这是普通文件"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-6-文件目录操作"><a href="#2-6-文件目录操作" class="headerlink" title="2.6 文件目录操作"></a>2.6 文件目录操作</h3><p>我们经常需要读取一个目录下的所有文件名,所以一下介绍如何读取一个文件下的目录</p>
<ol>
<li><p>打开目录opendir</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="function">DIR *<span class="title">opendir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line">功能：打开一个目录</span><br><span class="line">参数：</span><br><span class="line">    name：目录名</span><br><span class="line">返回值：</span><br><span class="line">    成功：返回指向该目录结构体指针</span><br><span class="line">    失败：<span class="literal">NULL</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>读取目录</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="function">struct dirent *<span class="title">readdir</span><span class="params">(DIR *dirp)</span></span>;</span><br><span class="line">功能：读取目录</span><br><span class="line">参数：</span><br><span class="line">    dirp：opendir的返回值</span><br><span class="line">返回值：</span><br><span class="line">    成功：目录结构体指针</span><br><span class="line">    失败：<span class="literal">NULL</span></span><br></pre></td></tr></table></figure>

<p>相关结构体说明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">ino_t</span> d_ino;                  <span class="comment">// 此目录进入点的inode</span></span><br><span class="line">    <span class="keyword">off_t</span> d_off;                    <span class="comment">// 目录文件开头至此目录进入点的位移</span></span><br><span class="line">    <span class="keyword">signed</span> <span class="keyword">short</span> <span class="keyword">int</span> d_reclen;      <span class="comment">// d_name 的长度, 不包含NULL 字符</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> d_type;           <span class="comment">// d_type 所指的文件类型 </span></span><br><span class="line">    <span class="keyword">char</span> d_name[<span class="number">256</span>];               <span class="comment">// 文件名</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>关闭目录</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">   <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">closedir</span><span class="params">(DIR *dirp)</span></span>;</span><br><span class="line">   功能：关闭目录</span><br><span class="line">   参数：</span><br><span class="line">       dirp：opendir返回的指针</span><br><span class="line">   返回值：</span><br><span class="line">       成功：<span class="number">0</span></span><br><span class="line">       失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>读取目录代码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DIR *dir=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">dirp</span>=<span class="title">NULL</span>;</span></span><br><span class="line">	dir = opendir(<span class="string">"./"</span>);</span><br><span class="line">	<span class="keyword">if</span>(dir == <span class="literal">NULL</span>)</span><br><span class="line">		perror(<span class="string">""</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		dirp = readdir(dir);</span><br><span class="line">		<span class="keyword">if</span>(dirp == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s "</span>,dirp-&gt;d_name);</span><br><span class="line">		<span class="keyword">if</span>(dirp-&gt;d_type == DT_DIR)</span><br><span class="line">		&#123;</span><br><span class="line">			 <span class="built_in">printf</span>(<span class="string">"目录\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(dirp-&gt;d_type == DT_REG)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"普通文件\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	closedir(dir);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h2 id="3-linux多任务编程之进程"><a href="#3-linux多任务编程之进程" class="headerlink" title="3 linux多任务编程之进程"></a>3 linux多任务编程之进程</h2><h3 id="3-1-进程的概念"><a href="#3-1-进程的概念" class="headerlink" title="3.1 进程的概念"></a>3.1 进程的概念</h3><p>我们平时写的 C 语言代码，通过编译器编译，最终它会成为一个可执行程序，当这个可执行程序运行起来后（没有结束之前），它就成为了一个进程。<br>程序是存放在存储介质上的一个可执行文件，而进程是程序执行的过程。进程的状态是变化的，其包括进程的创建、调度和消亡。程序是静态的，进程是动态的。</p>
<p><strong>单道、多道程序设计(了解)</strong><br>1 单道程序设计<br>所有进程一个一个排队执行。若A阻塞，B只能等待，即使CPU处于空闲状态。而在人机交互时阻塞的出现是必然的。所有这种模型在系统资源利用上及其不合理，在计算机发展历史上存在不久，大部分便被淘汰了。<br>2 多道程序设计<br>在计算机内存中同时存放几道相互独立的程序，它们在管理程序控制之下，相互穿插的运行。多道程序设计必须有硬件基础作为保证。<br>在计算机中时钟中断即为多道程序设计模型的理论基础。并发时，任意进程在执行期间都不希望放弃cpu。因此系统需要一种强制让进程让出cpu资源的手段。时钟中断有硬件基础作为保障，对进程而言不可抗拒。 操作系统中的中断处理函数，来负责调度程序执行。<br>在多道程序设计模型中，多个进程轮流使用CPU (分时复用CPU资源)。而当下常见CPU为纳秒级，1秒可以执行大约10亿条指令。由于人眼的反应速度是毫秒级，所以看似同时在运行。<br>1s = 1000ms<br>1ms = 1000us<br>1us = 1000ns<br>1s = 1000000000ns</p>
<p><strong>并行和并发(理解)</strong></p>
<p><strong>并行(parallel)：</strong>指在同一时刻，有多条指令在多个处理器上同时执行。 </p>
<p><img src="/2019/11/03/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/assets%5C1562224398265.png" alt="1562224398265"></p>
<p><strong>并发(concurrency)</strong>：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。 </p>
<p><img src="/2019/11/03/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/assets%5C1562224438938.png" alt="1562224438938"></p>
<p><strong>进程控制块PCB(了解)</strong></p>
<p>进程运行时，内核为进程每个进程分配一个PCB（进程控制块），维护进程相关的信息，Linux内核的进程控制块是task_struct结构体。</p>
<p>在 /usr/src/linux-headers-xxx/include/linux/sched.h 文件中可以查看struct task_struct 结构体定义：<br>ubunqu@-:~/share$ vim /usr/src/linux-headers-4.10.0-28/include/linux/sched.h </p>
<p><img src="/2019/11/03/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/assets%5C1562224605074.png" alt="1562224605074"></p>
<p>其内部成员有很多，我们掌握以下部分即可：<br>进程id。系统中每个进程有唯一的id，在C语言中用pid_t类型表示，其实就是一个非负整数。<br>进程的状态，有就绪、运行、挂起、停止等状态。<br>进程切换时需要保存和恢复的一些CPU寄存器。<br>描述虚拟地址空间的信息。<br>描述控制终端的信息。<br>当前工作目录（Current Working Directory）。<br>umask掩码。<br>文件描述符表，包含很多指向file结构体的指针。<br>和信号相关的信息。<br>用户id和组id。<br>会话（Session）和进程组。<br>进程可以使用的资源上限（Resource Limit）。</p>
<h3 id="3-2-进程的状态"><a href="#3-2-进程的状态" class="headerlink" title="3.2 进程的状态"></a>3.2 进程的状态</h3><p>进程状态反映进程执行过程的变化。这些状态随着进程的执行和外界条件的变化而转换。<br>在三态模型中，进程状态分为三个基本状态，即运行态，就绪态，阻塞态。<br>在五态模型中，进程分为新建态、终止态，运行态，就绪态，阻塞</p>
<p><img src="/2019/11/03/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/assets%5C1562224871507.png" alt="1562224871507"></p>
<p>①TASK_RUNNING：进程正在被CPU执行。当一个进程刚被创建时会处于TASK_RUNNABLE，表示己经准备就绪，正等待被调度。<br>②TASK_INTERRUPTIBLE（可中断）：进程正在睡眠（也就是说它被阻塞）等待某些条件的达成。一旦这些条件达成，内核就会把进程状态设置为运行。处于此状态的进程也会因为接收到信号而提前被唤醒，比如给一个TASK_INTERRUPTIBLE状态的进程发送SIGKILL信号，这个进程将先被唤醒（进入TASK_RUNNABLE状态），然后再响应SIGKILL信号而退出（变为TASK_ZOMBIE状态），并不会从TASK_INTERRUPTIBLE状态直接退出。<br>③TASK_UNINTERRUPTIBLE（不可中断）：处于等待中的进程，待资源满足时被唤醒，但不可以由其它进程通过信号或中断唤醒。由于不接受外来的任何信号，因此无法用kill杀掉这些处于该状态的进程。而TASK_UNINTERRUPTIBLE状态存在的意义就在于，内核的某些处理流程是不能被打断的。如果响应异步信号，程序的执行流程中就会被插入一段用于处理异步信号的流程，于是原有的流程就被中断了，这可能使某些设备陷入不可控的状态。处于TASK_UNINTERRUPTIBLE状态一般总是非常短暂的，通过ps命令基本上不可能捕捉到。<br>④TASK_ZOMBIE（僵死）：表示进程已经结束了，但是其父进程还没有调用wait4或waitpid()来释放进程描述符。为了父进程能够获知它的消息，子进程的进程描述符仍然被保留着。一旦父进程调用了wait4()，进程描述符就会被释放。<br>⑤TASK_STOPPED（停止）：进程停止执行。当进程接收到SIGSTOP，SIGTSTP，SIGTTIN，SIGTTOU等信号的时候。此外，在调试期间接收到任何信号，都会使进程进入这种状态。当接收到SIGCONT信号，会重新回到TASK_RUNNABLE。<br>如何查看进程状态：  ps   aux</p>
<p><img src="/2019/11/03/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/assets%5C1562225021136.png" alt="1562225021136"></p>
<p>stat中的参数意义如下：</p>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>D</td>
<td>不可中断 Uninterruptible（usually IO）</td>
</tr>
<tr>
<td>R</td>
<td>正在运行，或在队列中的进程</td>
</tr>
<tr>
<td>S(大写)</td>
<td>处于休眠状态</td>
</tr>
<tr>
<td>T</td>
<td>停止或被追踪</td>
</tr>
<tr>
<td>Z</td>
<td>僵尸进程</td>
</tr>
<tr>
<td>W</td>
<td>进入内存交换（从内核2.6开始无效）</td>
</tr>
<tr>
<td>X</td>
<td>死掉的进程</td>
</tr>
<tr>
<td>&lt;</td>
<td>高优先级</td>
</tr>
<tr>
<td>N</td>
<td>低优先级</td>
</tr>
<tr>
<td>s</td>
<td>包含子进程</td>
</tr>
<tr>
<td>+</td>
<td>位于前台的进程组</td>
</tr>
</tbody></table>
<p>ps命令可以查看进程信息:</p>
<p>进程是一个具有一定独立功能的程序，它是操作系统动态执行的基本单元。 </p>
<p>ps命令可以查看进程的详细状况，常用选项(选项可以不加“-”)如下：</p>
<table>
<thead>
<tr>
<th><strong>选项</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>-u</td>
<td>显示进程的详细状态</td>
</tr>
<tr>
<td>-a</td>
<td>显示终端上的所有进程，包括其他用户的进程</td>
</tr>
<tr>
<td>-x</td>
<td>显示没有控制终端的进程</td>
</tr>
<tr>
<td>-w</td>
<td>显示加宽，以便显示更多的信息</td>
</tr>
<tr>
<td>-r</td>
<td>只显示正在运行的进程</td>
</tr>
</tbody></table>
<h3 id="3-3-进程号"><a href="#3-3-进程号" class="headerlink" title="3.3 进程号"></a>3.3 进程号</h3><p>每个进程都由一个进程号来标识，其类型为 pid_t（整型），进程号的范围：0～32767。进程号总是唯一的，但进程号可以重用。当一个进程终止后，其进程号就可以再次使用。</p>
<p>接下来，再给大家介绍三个不同的进程号。<br>进程号（PID）：<br>标识进程的一个非负整型数。<br>父进程号（PPID）：<br>任何进程（ 除 init 进程）都是由另一个进程创建，该进程称为被创建进程的父进程，对应的进程号称为父进程号（PPID）。如，A 进程创建了 B 进程，A 的进程号就是 B 进程的父进程号。<br>进程组号（PGID）：<br>进程组是一个或多个进程的集合。他们之间相互关联，进程组可以接收同一终端的各种信号，关联的进程有一个进程组号（PGID） 。这个过程有点类似于 QQ 群，组相当于 QQ 群，各个进程相当于各个好友，把各个好友都拉入这个 QQ 群里，主要是方便管理，特别是通知某些事时，只要在群里吼一声，所有人都收到，简单粗暴。但是，这个进程组号和 QQ 群号是有点区别的，默认的情况下，当前的进程号会当做当前的进程组号。</p>
<p><strong>getpid函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> getpid(<span class="keyword">void</span>);</span><br><span class="line">功能：</span><br><span class="line">    获取本进程号（PID）</span><br><span class="line">参数：</span><br><span class="line">    无</span><br><span class="line">返回值：</span><br><span class="line">    本进程号</span><br></pre></td></tr></table></figure>

<p><strong>getppid函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> getppid(<span class="keyword">void</span>);</span><br><span class="line">功能：</span><br><span class="line">    获取调用此函数的进程的父进程号（PPID）</span><br><span class="line">参数：</span><br><span class="line">    无</span><br><span class="line">返回值：</span><br><span class="line">    调用此函数的进程的父进程号（PPID）</span><br></pre></td></tr></table></figure>

<p><strong>getpgid函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> getpgid(<span class="keyword">pid_t</span> pid);</span><br><span class="line">功能：</span><br><span class="line">    获取进程组号（PGID）</span><br><span class="line">参数：</span><br><span class="line">    pid：进程号</span><br><span class="line">返回值：</span><br><span class="line">    参数为 <span class="number">0</span> 时返回当前进程组号，否则返回参数指定的进程的进程组号</span><br></pre></td></tr></table></figure>

<p>示例代码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid, ppid, pgid;</span><br><span class="line">    pid = getpid();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pid = %d\n"</span>, pid);</span><br><span class="line">   	ppid = getppid();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ppid = %d\n"</span>, ppid);</span><br><span class="line">    pgid = getpgid(pid);</span><br><span class="line">   	<span class="built_in">printf</span>(<span class="string">"pgid = %d\n"</span>, pgid);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-4-fork创建进程"><a href="#3-4-fork创建进程" class="headerlink" title="3.4 fork创建进程"></a>3.4 fork创建进程</h3><p>系统允许一个进程创建新进程，新进程即为子进程，子进程还可以创建新的子进程，形成进程树结构模型。 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> fork(<span class="keyword">void</span>);</span><br><span class="line">功能：</span><br><span class="line">    用于从一个已存在的进程中创建一个新进程，新进程称为子进程，原进程称为父进程。</span><br><span class="line">参数：</span><br><span class="line">    无</span><br><span class="line">返回值：</span><br><span class="line">    成功：子进程中返回 <span class="number">0</span>，父进程中返回子进程 ID。<span class="keyword">pid_t</span>，为整型。</span><br><span class="line">    失败：返回<span class="number">-1</span>。</span><br><span class="line">    失败的两个主要原因是：</span><br><span class="line">        <span class="number">1</span>）当前的进程数已经达到了系统规定的上限，这时 errno 的值被设置为 EAGAIN。</span><br><span class="line">        <span class="number">2</span>）系统内存不足，这时 errno 的值被设置为 ENOMEM。</span><br></pre></td></tr></table></figure>

<p><strong>fork出来的子进程和父进程之间的关系:</strong></p>
<p>使用fork函数得到的子进程是父进程的一个复制品，它从父进程处继承了整个进程的地址空间。<br>地址空间:<br>      包括进程上下文、进程堆栈、打开的文件描述符、信号控制设定、进程优先级、进程组号等。<br>子进程所独有的只有它的进程号，计时器等。因此，使用fork函数的代价是很大的.</p>
<p><img src="/2019/11/03/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/assets%5C1562227954935.png" alt="1562227954935"></p>
<p>示例代码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	pid = fork();</span><br><span class="line">	<span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">		perror(<span class="string">""</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)<span class="comment">//子进程pid返回值=0</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"I am child process\n"</span>);</span><br><span class="line">			sleep(<span class="number">1</span>);</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span><span class="comment">//父进程的pid&gt;0</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"I am father process\n"</span>);</span><br><span class="line">			sleep(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从程序可以看出，子进程对变量所做的改变并不影响父进程中该变量的值，说明父子进程各自拥有自己的地址空间。<br>一般来说，在fork之后是父进程先执行还是子进程先执行是不确定的。这取决于内核所使用的调度算法。<br>如要求父子进程之间相互同步，则要求某种形式的进程间通信。</p>
<h3 id="3-5-回收子进程资源"><a href="#3-5-回收子进程资源" class="headerlink" title="3.5 回收子进程资源"></a>3.5 回收子进程资源</h3><p>在每个进程退出的时候，内核释放该进程所有的资源、包括打开的文件、占用的内存等。但是仍然为其保留一定的信息，这些信息主要主要指进程控制块PCB的信息（包括进程号、退出状态、运行时间等）。<br>父进程可以通过调用wait或waitpid得到它的退出状态同时彻底清除掉这个进程。<br>wait() 和 waitpid() 函数的功能一样，区别在于，wait() 函数会阻塞，waitpid() 可以设置不阻塞，waitpid() 还可以指定等待哪个子进程结束。<br>注意：一次wait或waitpid调用只能清理一个子进程，清理多个子进程应使用循环。</p>
<h4 id="3-5-1-wait函数"><a href="#3-5-1-wait函数" class="headerlink" title="3.5.1 wait函数"></a>3.5.1 wait函数</h4><p>函数说明:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> wait(<span class="keyword">int</span> *status);</span><br><span class="line">功能：</span><br><span class="line">    等待任意一个子进程结束，如果任意一个子进程结束了，此函数会回收该子进程的资源。</span><br><span class="line">参数：</span><br><span class="line">    status : 进程退出时的状态信息。</span><br><span class="line">返回值：</span><br><span class="line">    成功：已经结束子进程的进程号</span><br><span class="line">    失败： <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>调用 wait() 函数的进程会挂起（阻塞），直到它的一个子进程退出或收到一个不能被忽视的信号时才被唤醒（相当于继续往下执行）。<br>若调用进程没有子进程，该函数立即返回；若它的子进程已经结束，该函数同样会立即返回，并且会回收那个早已结束进程的资源。<br>所以，wait()函数的主要功能为回收已经结束子进程的资源。<br>如果参数 status 的值不是 NULL，wait() 就会把子进程退出时的状态取出并存入其中，这是一个整数值（int），指出了子进程是正常退出还是被非正常结束的。<br>这个退出信息在一个 int 中包含了多个字段，直接使用这个值是没有意义的，我们需要用宏定义取出其中的每个字段。</p>
<p>取出子进程的退出信息<br>WIFEXITED(status)<br>    如果子进程是正常终止的，取出的字段值非零。<br>WEXITSTATUS(status)<br>    返回子进程的退出状态，退出状态保存在status变量的8~16位。在用此宏前应先用宏WIFEXITED判断子进程是否正常退出，正常退出才可以使用此宏。<br>注意：此status是个wait的参数指向的整型变量。</p>
<h4 id="3-5-2-waitpid函数"><a href="#3-5-2-waitpid函数" class="headerlink" title="3.5.2 waitpid函数"></a>3.5.2 waitpid函数</h4><p>函数说明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> waitpid(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *status, <span class="keyword">int</span> options);</span><br><span class="line">功能:</span><br><span class="line">    等待子进程终止，如果子进程终止了，此函数会回收子进程的资源。</span><br><span class="line">参数：</span><br><span class="line">    pid : 参数 pid 的值有以下几种类型：</span><br><span class="line">      pid &gt; <span class="number">0</span>  等待进程 ID 等于 pid 的子进程。</span><br><span class="line">      pid = <span class="number">0</span>  等待同一个进程组中的任何子进程，如果子进程已经加入了别的进程组，waitpid 不会等待它。</span><br><span class="line">      pid = <span class="number">-1</span> 等待任一子进程，此时 waitpid 和 wait 作用一样。</span><br><span class="line">      pid &lt; <span class="number">-1</span> 等待指定进程组中的任何子进程，这个进程组的 ID 等于 pid 的绝对值。</span><br><span class="line">    status : 进程退出时的状态信息。和 wait() 用法一样。</span><br><span class="line">    options : options 提供了一些额外的选项来控制 waitpid()。</span><br><span class="line">            <span class="number">0</span>：同 wait()，阻塞父进程，等待子进程退出。</span><br><span class="line">            WNOHANG：没有任何已经结束的子进程，则立即返回。</span><br><span class="line">            WUNTRACED：如果子进程暂停了则此函数马上返回，并且不予以理会子进程的结束状态。（由于涉及到一些跟踪调试方面的知识，加之极少用到）</span><br><span class="line">返回值：</span><br><span class="line">    waitpid() 的返回值比 wait() 稍微复杂一些，一共有 <span class="number">3</span> 种情况：</span><br><span class="line">        <span class="number">1</span>) 当正常返回的时候，waitpid() 返回收集到的已经回收子进程的进程号；</span><br><span class="line">        <span class="number">2</span>) 如果设置了选项 WNOHANG，而调用中 waitpid() 发现没有已退出的子进程可等待，则返回 <span class="number">0</span>；</span><br><span class="line">        <span class="number">3</span>) 如果调用中出错，则返回<span class="number">-1</span>，这时 errno 会被设置成相应的值以指示错误所在，如：当 pid 所对应的子进程不存在，或此进程存在，但不是调用进程的子进程，waitpid() 就会出错返回，这时 errno 被设置为 ECHILD；</span><br></pre></td></tr></table></figure>

<h3 id="3-6-僵尸进程孤儿进程守护进程"><a href="#3-6-僵尸进程孤儿进程守护进程" class="headerlink" title="3.6 僵尸进程孤儿进程守护进程"></a>3.6 僵尸进程孤儿进程守护进程</h3><p><strong>3.6.1 僵尸进程</strong></p>
<p>进程终止，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成僵尸（Zombie）进程。<br>这样就会导致一个问题，如果进程不调用wait() 或 waitpid() 的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程，此即为僵尸进程的危害，应当避免。</p>
<p><strong>3.6.2 孤儿进程</strong></p>
<p>父进程运行结束，但子进程还在运行（未运行结束）的子进程就称为孤儿进程（Orphan Process）。<br>每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为 init ，而 init 进程会循环地 wait() 它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init 进程就会代表党和政府出面处理它的一切善后工作。<br>因此孤儿进程并不会有什么危害。</p>
<p><strong>3.6.3守护进程</strong><br>守护进程（Daemon Process），也就是通常说的 Daemon 进程（精灵进程），是 Linux 中的后台服务进程。它是一个生存期较长的进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。一般采用以d结尾的名字。<br>守护进程是个特殊的孤儿进程，这种进程脱离终端，为什么要脱离终端呢？之所以脱离于终端是为了避免进程被任何终端所产生的信息所打断，其在执行过程中的信息也不在任何终端上显示。由于在 Linux 中，每一个系统与用户进行交流的界面称为终端，每一个从此终端开始运行的进程都会依附于这个终端，这个终端就称为这些进程的控制终端，当控制终端被关闭时，相应的进程都会自动关闭。<br>Linux 的大多数服务器就是用守护进程实现的。比如，Internet 服务器 inetd，Web 服务器 httpd 等。</p>
<p>在了解守护进程之前我们需要先了解终端和进程组以及会话</p>
<p><strong>终端:</strong></p>
<p>在UNIX系统中，用户通过终端登录系统后得到一个Shell进程，这个终端成为Shell进程的控制终端（Controlling Terminal），进程中，控制终端是保存在PCB中的信息，而fork会复制PCB中的信息，因此由Shell进程启动的其它进程的控制终端也是这个终端。<br>默认情况下（没有重定向），每个进程的标准输入、标准输出和标准错误输出都指向控制终端，进程从标准输入读也就是读用户的键盘输入，进程往标准输出或标准错误输出写也就是输出到显示器上。<br>信号中还讲过，在控制终端输入一些特殊的控制键可以给前台进程发信号，例如Ctrl+C表示SIGINT，Ctrl+\表示SIGQUIT。 </p>
<p>函数说明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">ttyname</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line">功能：由文件描述符查出对应的文件名</span><br><span class="line">参数：</span><br><span class="line">    fd：文件描述符</span><br><span class="line">返回值：</span><br><span class="line">    成功：终端名</span><br><span class="line">    失败：<span class="literal">NULL</span></span><br></pre></td></tr></table></figure>

<p>下面我们借助ttyname函数，通过实验看一下各种不同的终端所对应的设备文件名： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fd 0: %s\n"</span>, ttyname(<span class="number">0</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fd 1: %s\n"</span>, ttyname(<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fd 2: %s\n"</span>, ttyname(<span class="number">2</span>));</span><br><span class="line">	 <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>进程组</strong><br>进程组，也称之为作业。BSD于1980年前后向Unix中增加的一个新特性。代表一个或多个进程的集合。<br>每个进程都属于一个进程组。在waitpid函数和kill函数的参数中都曾使用到。操作系统设计的进程组的概念，是为了简化对多个进程的管理。<br>当父进程，创建子进程的时候，默认子进程与父进程属于同一进程组。进程组ID为第一个进程ID(组长进程)。所以，组长进程标识：其进程组ID为其进程ID</p>
<p>可以使用kill -SIGKILL -进程组ID(负的)来将整个进程组内的进程全部杀死：</p>
<p><img src="/2019/11/03/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/assets%5C1562229773072.png" alt="1562229773072"></p>
<p>组长进程可以创建一个进程组，创建该进程组中的进程，然后终止。只要进程组中有一个进程存在，进程组就存在，与组长进程是否终止无关。<br>进程组生存期：进程组创建到最后一个进程离开(终止或转移到另一个进程组)。<br>一个进程可以为自己或子进程设置进程组ID。</p>
<p>相关函数说明:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> getpgrp(<span class="keyword">void</span>);                 <span class="comment">/* POSIX.1 version */</span></span><br><span class="line">功能：获取当前进程的进程组ID</span><br><span class="line">参数：无</span><br><span class="line">返回值：总是返回调用者的进程组ID</span><br><span class="line"><span class="keyword">pid_t</span> getpgid(<span class="keyword">pid_t</span> pid);</span><br><span class="line">功能：获取指定进程的进程组ID</span><br><span class="line">参数：</span><br><span class="line">    pid：进程号，如果pid = <span class="number">0</span>，那么该函数作用和getpgrp一样</span><br><span class="line">返回值：</span><br><span class="line">    成功：进程组ID</span><br><span class="line">    失败：<span class="number">-1</span></span><br><span class="line"><span class="keyword">int</span> setpgid(<span class="keyword">pid_t</span> pid, <span class="keyword">pid_t</span> pgid)</span><br><span class="line">功能：</span><br><span class="line">    改变进程默认所属的进程组。通常可用来加入一个现有的进程组或创建一个新进程组。</span><br><span class="line">参数：</span><br><span class="line">    将参<span class="number">1</span>对应的进程，加入参<span class="number">2</span>对应的进程组中</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p><strong>会话(了解)</strong></p>
<p>会话是一个或多个进程组的集合。<br>一个会话可以有一个控制终端。这通常是终端设备或伪终端设备；<br>建立与控制终端连接的会话首进程被称为控制进程；<br>一个会话中的几个进程组可被分为一个前台进程组以及一个或多个后台进程组；<br>如果一个会话有一个控制终端，则它有一个前台进程组，其它进程组为后台进程组；<br>如果终端接口检测到断开连接，则将挂断信号发送至控制进程（会话首进程）。</p>
<p><img src="/2019/11/03/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/assets%5C1562229913108.png" alt="1562229913108"></p>
<p>创建会话注意事项</p>
<p>1) 调用进程不能是进程组组长，该进程变成新会话首进程(session header)<br>2) 该调用进程是组长进程，则出错返回<br>3) 该进程成为一个新进程组的组长进程<br>4) 需有root权限(ubuntu不需要)<br>5) 新会话丢弃原有的控制终端，该会话没有控制终端<br>6) 建立新会话时，先调用fork, 父进程终止，子进程调用setsid</p>
<p>API函数介绍<br>getsid函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> getsid(<span class="keyword">pid_t</span> pid);</span><br><span class="line">功能：获取进程所属的会话ID</span><br><span class="line">参数：</span><br><span class="line">    pid：进程号，pid为<span class="number">0</span>表示查看当前进程session ID</span><br><span class="line">返回值：</span><br><span class="line">    成功：返回调用进程的会话ID</span><br><span class="line">    失败：<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">组长进程不能成为新会话首进程，新会话首进程必定会成为组长进程。</span><br></pre></td></tr></table></figure>

<p>setsid函数：</p>
<p>setsid函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> setsid(<span class="keyword">void</span>);</span><br><span class="line">功能：</span><br><span class="line">    创建一个会话，并以自己的ID设置进程组ID，同时也是新会话的ID。调用了setsid函数的进程，既是新的会长，也是新的组长。</span><br><span class="line">参数：无</span><br><span class="line">返回值：</span><br><span class="line">    成功：返回调用进程的会话ID</span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p><strong>创建守护进程模型</strong></p>
<p>1) 创建子进程，父进程退出(必须)<br>所有工作在子进程中进行形式上脱离了控制终端<br>2) 在子进程中创建新会话(必须)<br>setsid()函数<br>使子进程完全独立出来，脱离控制<br>3) 改变当前目录为根目录(不是必须)<br>chdir()函数<br>防止占用可卸载的文件系统<br>也可以换成其它路径<br>4) 重设文件权限掩码(不是必须)<br>umask()函数<br>防止继承的文件创建屏蔽字拒绝某些权限<br>增加守护进程灵活性<br>5) 关闭文件描述符(不是必须)<br>继承的打开文件不会用到，浪费系统资源，无法卸载<br>6) 开始执行守护进程核心工作(必须)<br>守护进程退出处理程序模型</p>
<h3 id="3-7-vfork创建进程"><a href="#3-7-vfork创建进程" class="headerlink" title="3.7 vfork创建进程"></a>3.7 vfork创建进程</h3><p>vfork函数：创建一个新进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> vfork(<span class="keyword">void</span>)</span><br><span class="line">	功能：</span><br><span class="line">		vfork函数和fork函数一样都是在已有的进程中创建一个新的进程，但它们创建的子进程是有区别的。</span><br><span class="line">	返回值:</span><br><span class="line">		创建子进程成功，则在子进程中返回<span class="number">0</span>,父进程中返回子进程ID。出错则返回<span class="number">-1</span>。</span><br></pre></td></tr></table></figure>

<p>fork和vfork函数的区别：<br>vfork保证子进程先运行，在它调用exec或exit之后，父进程才可能被调度运行。<br>vfork和fork一样都创建一个子进程，但它并不将父进程的地址空间完全复制到子进程中，因为子进程会立即调用exec(或exit)，于是也就不访问该地址空间。相反，在子进程中调用exec或exit之前，它在父进程的地址空间中运行，在exec之后子进程会有自己的进程空间。</p>
<p><img src="/2019/11/03/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/assets%5C1562230481193.png" alt="1562230481193"></p>
<p>代码示例:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	pid = vfork();</span><br><span class="line">	<span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(<span class="string">""</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		sleep(<span class="number">5</span>);</span><br><span class="line">		<span class="comment">//子进程exec 或exit之前的代码运行在父进程的地址空间</span></span><br><span class="line">		execlp(<span class="string">"ls"</span>,<span class="string">"ls"</span>,<span class="literal">NULL</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);<span class="comment">// 退出进程 防止execl执行失败,运行至return</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 父进程vfrok之后会等待子进程退出或者调用exec,之后才</span></span><br><span class="line">		<span class="comment">// 开始调用运行</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"hello vfork\n"</span>);</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="3-8-exec进程的替换"><a href="#3-8-exec进程的替换" class="headerlink" title="3.8 exec进程的替换"></a>3.8 exec进程的替换</h3><p>在 Windows 平台下，我们可以通过双击运行可执行程序，让这个可执行程序成为一个进程；而在 Linux 平台，我们可以通过 ./ 运行，让一个可执行程序成为一个进程。<br>但是，如果我们本来就运行着一个程序（进程），我们如何在这个进程内部启动一个外部程序，由内核将这个外部程序读入内存，使其执行起来成为一个进程呢？这里我们通过 exec 函数族实现。<br>exec 函数族，顾名思义，就是一簇函数，在 Linux 中，并不存在 exec() 函数，exec 指的是一组函数，一共有 6 个：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> **environ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...<span class="comment">/* (char  *) NULL */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file,cconst <span class="keyword">char</span> *arg, ... <span class="comment">/* (char  *) NULL */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...<span class="comment">/*, (char *) NULL, char * const envp[] */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvpe</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>;</span><br></pre></td></tr></table></figure>

<p>六个exec函数中只有execve是真正意义的系统调用(内核提供的接口)，其它函数都是在此基础上经过封装的库函数。<br>l(list)：<br>        参数地址列表，以空指针结尾。<br>参数地址列表<br>    char *arg0, char *arg1, …, char *argn, NULL<br>v(vector)：<br>        存有各参数地址的指针数组的地址。<br>        使用时先构造一个指针数组，指针数组存各参数的地址，然后将该指针数组地址作为函数的参数。</p>
<p>p(path)<br>        按PATH环境变量指定的目录搜索可执行文件。<br>        以p结尾的exec函数取文件名做为参数。当指定filename作为参数时，若filename中包含/，则将其视为路径名，并直接到指定的路径中执行程序。<br>e(environment)：<br>        存有环境变量字符串地址的指针数组的地址。execle和execve改变的是exec启动的程序的环境变量（新的环境变量完全由environment指定），其他四个函数启动的程序则使用默认系统环境变量。</p>
<p>exec函数族与一般的函数不同，exec函数族中的函数执行成功后不会返回。只有调用失败了，它们才会返回－1。失败后从原程序的调用点接着往下执行。<br>在平时的编程中，如果用到了exec函数族，一定要记得加错误判断语句。</p>
<p>exec函数族取代调用进程的数据段、代码段和堆栈段。</p>
<p><img src="/2019/11/03/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/assets%5C1562230818694.png" alt="1562230818694"></p>
<p>一个进程调用exec后，除了进程ID，进程还保留了下列特征不变：<br>父进程号<br>进程组号<br>控制终端<br>根目录<br>当前工作目录<br>进程信号屏蔽集<br>未处理信号<br>…</p>
<h2 id="4-linux进程间通信之无名管道"><a href="#4-linux进程间通信之无名管道" class="headerlink" title="4 linux进程间通信之无名管道"></a>4 linux进程间通信之无名管道</h2><h3 id="4-1-无名管道概述"><a href="#4-1-无名管道概述" class="headerlink" title="4.1 无名管道概述"></a>4.1 无名管道概述</h3><p>管道(pipe)又称无名管道。<br>无名管道是一种特殊类型的文件，在应用层体现为两个打开的文件描述符。</p>
<p><img src="/2019/11/03/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/assets%5C1562231094936.png" alt="1562231094936"></p>
<p>管道是最古老的UNIX IPC方式，其<strong>特点</strong>是:<br>1、半双工，数据在同一时刻只能在一个方向上流动。<br>2、数据只能从管道的一端写入，从另一端读出。<br>3、写入管道中的数据遵循先入先出的规则。<br>4、管道所传送的数据是无格式的，这要求管道的读出方与写入方必须事先约定好数据的格式，如多少字节算一个消息等。<br>5、管道不是普通的文件，不属于某个文件系统，其只存在于内存中。<br>6、管道在内存中对应一个缓冲区。不同的系统其大小不一定相同。<br>7、从管道读数据是一次性操作，数据一旦被读走，它就从管道中被抛弃，释放空间以便写更多的数据。<br>8、管道没有名字，只能在具有公共祖先的进程之间使用。 </p>
<h3 id="4-2-无名管道创建和使用"><a href="#4-2-无名管道创建和使用" class="headerlink" title="4.2 无名管道创建和使用"></a>4.2 无名管道创建和使用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> filedes[<span class="number">2</span>])</span></span>;</span><br><span class="line">	功能：经由参数filedes返回两个文件描述符</span><br><span class="line">	参数：</span><br><span class="line">filedes为<span class="keyword">int</span>型数组的首地址，其存放了管道的文件描述符fd[<span class="number">0</span>]、fd[<span class="number">1</span>]。</span><br><span class="line">filedes[<span class="number">0</span>]为读而打开，filedes[<span class="number">1</span>]为写而打开管道，filedes[<span class="number">0</span>]的输出是filedes[<span class="number">1</span>]的输入。</span><br><span class="line">	返回值：</span><br><span class="line">	成功：返回 <span class="number">0</span></span><br><span class="line">	失败：返回<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p><img src="/2019/11/03/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/assets%5C1562231172305.png" alt="1562231172305"></p>
<p>代码示例:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	pipe(fd);<span class="comment">//创建管道放到fork之前</span></span><br><span class="line">	pid = fork();</span><br><span class="line">	<span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">		perror(<span class="string">""</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		sleep(<span class="number">3</span>);</span><br><span class="line">		<span class="comment">//fd[1]是写端</span></span><br><span class="line">		<span class="built_in">write</span>(fd[<span class="number">1</span>],<span class="string">"hello"</span>,<span class="number">5</span>);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">close</span>(fd[<span class="number">1</span>]);</span><br><span class="line">		<span class="comment">//fd[0] 读端</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">char</span> buf[<span class="number">256</span>]=<span class="string">""</span>;</span><br><span class="line">			sleep(<span class="number">1</span>);</span><br><span class="line">			<span class="built_in">read</span>(fd[<span class="number">0</span>],buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"[%s]\n"</span>,buf);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-3-无名管道读写的特点"><a href="#4-3-无名管道读写的特点" class="headerlink" title="4.3 无名管道读写的特点"></a>4.3 无名管道读写的特点</h3><p>从管道中读数据的特点<br>        1、默认用read函数从管道中读数据是阻塞的。<br>        2、调用write函数向管道里写数据，当缓冲区已满时write也会阻塞。<br>        3、通信过程中，读端口全部关闭后，写进程向管道内写数据时，写进程会（收到SIGPIPE信号）退出。<br>从管道中读数据的特点<br>        编程时可通过fcntl函数设置文件的阻塞特性。<br>        设置为阻塞：<br>            fcntl(fd, F_SETFL, 0);<br>        设置为非阻塞：<br>            fcntl(fd, F_SETFL, O_NONBLOCK);</p>
<h2 id="5-linux进程间通信之有名管道"><a href="#5-linux进程间通信之有名管道" class="headerlink" title="5 linux进程间通信之有名管道"></a>5 linux进程间通信之有名管道</h2><h3 id="5-1-有名管道的特点"><a href="#5-1-有名管道的特点" class="headerlink" title="5.1 有名管道的特点"></a>5.1 有名管道的特点</h3><p>命名管道(FIFO)和管道(pipe)基本相同，但也有一些显著的不同，其特点是:<br>1、半双工，数据在同一时刻只能在一个方向上流动。<br>2、写入FIFO中的数据遵循先入先出的规则。<br>3、FIFO所传送的数据是无格式的，这要求FIFO的读出方与写入方必须事先约定好数据的格式，如多少字节算一个消息等。<br>4、FIFO在文件系统中作为一个特殊的文件而存在，但FIFO中的内容却存放在内存中。<br>5、管道在内存中对应一个缓冲区。不同的系统其大小不一定相同。<br>6、从FIFO读数据是一次性操作，数据一旦被读，它就从FIFO中被抛弃，释放空间以便写更多的数据。<br>7、当使用FIFO的进程退出后，FIFO文件将继续保存在文件系统中以便以后使用。<br>8、FIFO有名字，不相关的进程可以通过打开命名管道进行通信。</p>
<h3 id="5-2-有名管道创建和使用"><a href="#5-2-有名管道创建和使用" class="headerlink" title="5.2 有名管道创建和使用"></a>5.2 有名管道创建和使用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FIFO文件的创建</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line">	参数：</span><br><span class="line">pathname：FIFO的路径名+文件名。</span><br><span class="line">mode：<span class="keyword">mode_t</span>类型的权限描述符。</span><br><span class="line">	返回值：</span><br><span class="line">成功：返回 <span class="number">0</span></span><br><span class="line">失败：如果文件已经存在，则会出错且返回<span class="number">-1</span>。</span><br></pre></td></tr></table></figure>

<h3 id="5-3-有名管道读写的特点"><a href="#5-3-有名管道读写的特点" class="headerlink" title="5.3 有名管道读写的特点"></a>5.3 有名管道读写的特点</h3><p>操作FIFO文件时的特点<br>        系统调用的I/O函数都可以作用于FIFO，如open、close、read、write等。<br>打开FIFO时，非阻塞标志(O_NONBLOCK)产生下列影响:<br>特点一：<br>不指定O_NONBLOCK(即open没有位或O_NONBLOCK)<br>1、open以只读方式打开FIFO时，要阻塞到某个进程为写而打开此FIFO<br>2、open以只写方式打开FIFO时，要阻塞到某个进程为读而打开此FIFO。<br>3、open以只读、只写方式打开FIFO时会阻塞，调用read函数从FIFO里读数据时read也会阻塞。<br>4、通信过程中若写进程先退出了，则调用read函数从FIFO里读数据时不阻塞；若写进程又重新运行，则调用read函数从FIFO里读数据时又恢复阻塞。<br>5、通信过程中，读进程退出后，写进程向命名管道内写数据时，写进程也会（收到SIGPIPE信号）退出。<br>6、调用write函数向FIFO里写数据，当缓冲区已满时write也会阻塞。</p>
<p>打开FIFO时，非阻塞标志(O_NONBLOCK)产生下列影响:<br>特点二：<br>指定O_NONBLOCK(即open位或O_NONBLOCK)<br>1、先以只读方式打开：如果没有进程已经为写而打开一个FIFO, 只读open成功，并且open不阻塞。<br>2、先以只写方式打开：如果没有进程已经为读而打开一个FIFO，只写open将出错返回-1。<br>3、read、write读写命名管道中读数据时不阻塞。<br>4、通信过程中，读进程退出后，写进程向命名管道内写数据时，写进程也会（收到SIGPIPE信号）退出。<br>注意：<br>open函数以可读可写方式打开FIFO文件时的特点：<br>        1、open不阻塞。<br>        2、调用read函数从FIFO里读数据时read会阻塞。<br>        3、调用write函数向FIFO里写数据，当缓冲区已满时write也会阻塞。</p>
<p><strong>练习:</strong></p>
<p>题目：实现单机QQ聊天<br>提示：<br>父进程创建子进程，实现多任务。<br>        父进程负责发信息(向FIFO里写数据)，子进程负责接收信息( 从FIFO里读数据)。<br>打开命名管道的用阻塞的方法打开。</p>
<p><img src="/2019/11/03/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/assets%5C1562231575174.png" alt="1562231575174"></p>
<h2 id="6-linux进程间通信之消息队列"><a href="#6-linux进程间通信之消息队列" class="headerlink" title="6 linux进程间通信之消息队列"></a>6 linux进程间通信之消息队列</h2><h3 id="6-1-消息队列概述"><a href="#6-1-消息队列概述" class="headerlink" title="6.1 消息队列概述"></a>6.1 消息队列概述</h3><p>消息队列是消息的链表，存放在内存中，由内核维护<br>消息队列的特点<br>1、消息队列中的消息是有类型的。<br>2、消息队列中的消息是有格式的。<br>3、消息队列可以实现消息的随机查询。消息不一定要以先进先出的次序读取，编程时可以按消息的类型读取。<br>4、消息队列允许一个或多个进程向它写入或者读取消息。<br>5、与无名管道、命名管道一样，从消息队列中读出消息，消息队列中对应的数据都会被删除。</p>
<p>6、每个消息队列都有消息队列标识符，消息队列的标识符在整个系统中是唯一的。</p>
<p>7、只有内核重启或人工删除消息队列时，该消息队列才会被删除。若不人工删除消息队列，消息队列会一直存在于系统中。</p>
<p>Ø在ubuntu 某些版本中消息队列限制值如下:</p>
<p>Ø每个消息内容最多为8K字节</p>
<p>Ø每个消息队列容量最多为16K字节</p>
<p>Ø系统中消息队列个数最多为1609个</p>
<p>Ø系统中消息个数最多为16384个</p>
<h3 id="6-2-消息队列创建和使用"><a href="#6-2-消息队列创建和使用" class="headerlink" title="6.2 消息队列创建和使用"></a>6.2 消息队列创建和使用</h3><p>System V提供的IPC通信机制需要一个key值，通过key值就可在系统内获得一个唯一的消息队列标识符。<br>key值可以是人为指定的，也可以通过ftok函数获得。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line">	<span class="keyword">key_t</span> ftok(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> proj_id)；</span><br><span class="line">	功能：</span><br><span class="line">	    获得项目相关的唯一的IPC键值。</span><br><span class="line">	参数：</span><br><span class="line">	    pathname：路径名</span><br><span class="line">	    proj_id：项目ID，非<span class="number">0</span>整数(只有低<span class="number">8</span>位有效)</span><br><span class="line">	返回值：</span><br><span class="line">	    成功返回key值，失败返回 <span class="number">-1</span>。</span><br></pre></td></tr></table></figure>

<p><strong>创建消息队列:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line">	int msgget(key_t key, int msgflg)；</span><br><span class="line">	功能：</span><br><span class="line">		创建一个新的或打开一个已经存在的消息队列。不同的进程调用此函数，只要用相同的key值就能得到同一个消息队列的标识符。</span><br><span class="line">	参数：</span><br><span class="line">key：IPC键值。</span><br><span class="line">msgflg：标识函数的行为及消息队列的权限。</span><br><span class="line">参数:</span><br><span class="line">msgflg的取值：</span><br><span class="line">IPC_CREAT：创建消息队列。</span><br><span class="line">IPC_EXCL：检测消息队列是否存在。</span><br><span class="line">位或权限位：消息队列位或权限位后可以设置消息队列的访问权限，格式和<span class="built_in">open</span>函数的<span class="keyword">mode_t</span>一样，但可执行权限未使用。</span><br><span class="line">返回值：</span><br><span class="line">	   成功：消息队列的标识符，失败：返回<span class="number">-1</span>。</span><br></pre></td></tr></table></figure>

<p>使用shell命令操作消息队列:<br>    查看消息队列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipcs -q</span><br></pre></td></tr></table></figure>

<p>​    删除消息队列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipcrm -q  msqid</span><br></pre></td></tr></table></figure>

<p>消息队列的消息的格式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _msg</span><br><span class="line">&#123;</span><br><span class="line">	long mtype;		/*消息类型*/</span><br><span class="line">	char mtext[100];	/*消息正文*/</span><br><span class="line">	...	/*消息的正文可以有多个成员*/</span><br><span class="line">&#125;MSG;</span><br></pre></td></tr></table></figure>

<p>​    消息类型必须是长整型的，而且必须是结构体类<br>​    型的第一个成员，类型下面是消息正文，正文可以<br>​    有多个成员（正文成员可以是任意数据类型的）。</p>
<p>​    消息类型必须是长整型的，而且必须是结构体类<br>​    型的第一个成员，类型下面是消息正文，正文可以<br>​    有多个成员（正文成员可以是任意数据类型的）。</p>
<p><strong>发送消息:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">msgsnd</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">const</span> <span class="keyword">void</span> *msgp,<span class="keyword">size_t</span> msgsz, <span class="keyword">int</span> msgflg)</span></span>;</span><br><span class="line">	功能：</span><br><span class="line">	    将新消息添加到消息队列。</span><br><span class="line">	参数：</span><br><span class="line">	    msqid：消息队列的标识符。</span><br><span class="line">	    msgp：待发送消息结构体的地址。</span><br><span class="line">	    msgsz：消息正文的字节数。</span><br><span class="line">	msgflg：函数的控制属性</span><br><span class="line">	<span class="number">0</span>：msgsnd调用阻塞直到条件满足为止。</span><br><span class="line">	IPC_NOWAIT: 若消息没有立即发送则调用该函数的进程会立即返回。</span><br><span class="line">	返回值：</span><br><span class="line">	成功：<span class="number">0</span>；失败：返回<span class="number">-1</span>。</span><br></pre></td></tr></table></figure>

<p><strong>接收消息：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line">	<span class="keyword">ssize_t</span> msgrcv(<span class="keyword">int</span> msqid, <span class="keyword">void</span> *msgp,  <span class="keyword">size_t</span> msgsz, <span class="keyword">long</span> msgtyp, <span class="keyword">int</span> msgflg);</span><br><span class="line">	功能：</span><br><span class="line">	    从标识符为msqid的消息队列中接收一个消息。一旦接收消息成功，则消息在消息队列中被删除。</span><br><span class="line">	参数：</span><br><span class="line">msqid：消息队列的标识符，代表要从哪个消息列中获取消息。</span><br><span class="line">msgp： 存放消息结构体的地址。</span><br><span class="line">msgsz：消息正文的字节数。</span><br><span class="line">msgtyp：消息的类型、可以有以下几种类型</span><br><span class="line">	msgtyp = <span class="number">0</span>：返回队列中的第一个消息</span><br><span class="line">	msgtyp &gt; <span class="number">0</span>：返回队列中消息类型为msgtyp的消息</span><br><span class="line">	msgtyp &lt; <span class="number">0</span>：返回队列中消息类型值小于或等于msgtyp绝对值的消息，如果这种消息有若干个，则取类型值		最小的消息。</span><br><span class="line">注意：</span><br><span class="line">  	若消息队列中有多种类型的消息，msgrcv获取消息的时候按消息类型获取，不是先进先出的。</span><br><span class="line">	在获取某类型消息的时候，若队列中有多条此类型的消息，则获取最先添加的消息，即先进先出原</span><br><span class="line">msgflg：函数的控制属性</span><br><span class="line"><span class="number">0</span>：msgrcv调用阻塞直到接收消息成功为止。</span><br><span class="line">MSG_NOERROR:若返回的消息字节数比nbytes字节数多,则消息就会截短到nbytes字节,且不通知消息发送进程。</span><br><span class="line">IPC_NOWAIT:调用进程会立即返回。若没有收到消息则立即返回<span class="number">-1</span>。</span><br><span class="line">	返回值：</span><br><span class="line">	    成功返回读取消息的长度，失败返回<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p><strong>消息队列的控制:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgctl</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">int</span> cmd, struct msqid_ds *buf)</span></span>;</span><br><span class="line">功能：</span><br><span class="line">    对消息队列进行各种控制，如修改消息队列的属性，或删除消息消息队列。</span><br><span class="line">参数：</span><br><span class="line">    msqid：消息队列的标识符。</span><br><span class="line">    cmd：函数功能的控制。</span><br><span class="line">    buf：msqid_ds数据类型的地址，用来存放或更改消息队列的属性。</span><br><span class="line"> cmd：函数功能的控制</span><br><span class="line">	IPC_RMID：删除由msqid指示的消息队列，将它从系统中删除并破坏相关数据结构。</span><br><span class="line">	IPC_STAT：将msqid相关的数据结构中各个元素的当前值存入到由buf指向的结构中。</span><br><span class="line">	IPC_SET：将msqid相关的数据结构中的元素设置为由buf指向的结构中的对应值。</span><br><span class="line">返回值：成功：返回 <span class="number">0</span>；失败：返回 <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p><strong>练习</strong><br>题目：消息队列实现多人聊天程序<br>提示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">消息结构体类型</span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">msg</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		<span class="keyword">long</span> type;		<span class="comment">//接收者类型</span></span><br><span class="line">		<span class="keyword">char</span> <span class="built_in">text</span>[<span class="number">100</span>];	<span class="comment">//发送内容</span></span><br><span class="line">		<span class="keyword">char</span> name[<span class="number">20</span>];	<span class="comment">//发送者姓名</span></span><br><span class="line">	&#125;MSG;</span><br></pre></td></tr></table></figure>

<p>每个程序都有两个任务，一个任务是负责接收消息，一个任务是负责发送消息，通过fork创建子进程实现多任务。<br>      一个进程负责接收信息，它只接收某种类型的消息，只要别的进程发送此类型的消息，此进程就能收到。收到后通过消息的name成员就可知道是谁发送的消息。<br>        另一个进程负责发信息，可以通过输入来决定发送消息的类型。<br>        设计程序的时候，接收消息的进程接收消息的类型不一样，这样就实现了发送的消息只被接收此类型消息的人收到，其它人收不到。这样就是实现了给特定的人发送消息。</p>
<p><img src="/2019/11/03/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/assets%5C1562232412175.png" alt="1562232412175"></p>
<h2 id="7-linux进程间通信之mmap"><a href="#7-linux进程间通信之mmap" class="headerlink" title="7 linux进程间通信之mmap"></a>7 linux进程间通信之mmap</h2><h3 id="7-1-mmap原理"><a href="#7-1-mmap原理" class="headerlink" title="7.1 mmap原理"></a>7.1 mmap原理</h3><p>存储映射I/O (Memory-mapped I/O) 使一个磁盘文件与存储空间中的一个缓冲区相映射。于是当从缓冲区中取数据，就相当于读文件中的相应字节。于此类似，将数据存入缓冲区，则相应的字节就自动写入文件。这样，就可在不适用read和write函数的情况下，使用地址（指针）完成I/O操作。<br>使用存储映射这种方法，首先应通知内核，将一个指定文件映射到存储区域中。这个映射工作可以通过mmap函数来实现。</p>
<p><strong>Mmap映射:</strong></p>
<p><img src="/2019/11/03/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/assets%5C1562232612771.png" alt="1562232612771"></p>
<h3 id="7-2-mmap使用"><a href="#7-2-mmap使用" class="headerlink" title="7.2 mmap使用"></a>7.2 mmap使用</h3><p>建立映射区:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>;</span><br><span class="line">addr 地址，填<span class="literal">NULL</span> </span><br><span class="line">length 长度 要申请的映射区的长度</span><br><span class="line">prot 权限</span><br><span class="line">PROT_READ 可读</span><br><span class="line">PROT_WRITE 可写</span><br><span class="line">flags 标志位</span><br><span class="line">MAP_SHARED 共享的 -- 对映射区的修改会影响源文件</span><br><span class="line">MAP_PRIVATE 私有的 </span><br><span class="line">fd 文件描述符 需要打开一个文件</span><br><span class="line">offset  指定一个偏移位置 ，从该位置开始映射 </span><br><span class="line">返回值</span><br><span class="line">成功 返回映射区的首地址</span><br><span class="line">失败 返回 MAP_FAILED ((<span class="keyword">void</span> *) <span class="number">-1</span>)</span><br></pre></td></tr></table></figure>

<p>释放映射区:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length)</span></span>;</span><br><span class="line">addr  映射区的首地址</span><br><span class="line">length 映射区的长度</span><br><span class="line">返回值</span><br><span class="line">成功 返回<span class="number">0</span></span><br><span class="line">失败 返回 <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>mmap疑问:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">如果文件偏移量随便填个数会怎么样？</span><br><span class="line">如果文件描述符先关闭，对mmap映射有没有影响？</span><br><span class="line">如果更改mem变量的地址，释放的时候munmap，传入mem还能成功吗？</span><br><span class="line">如果对mem越界操作会怎么样？</span><br><span class="line"><span class="built_in">open</span>的时候，可以新创建一个文件来创建映射区吗？</span><br><span class="line"><span class="built_in">open</span>文件选择O_WRONLY，可以吗？ </span><br><span class="line">当选择MAP_SHARED的时候，<span class="built_in">open</span>文件选择O_RDONLY，prot可以选择PROT_READ|PROT_WRITE吗？</span><br></pre></td></tr></table></figure>

<p>拓展文件大小:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">truncate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">off_t</span> length)</span></span>;</span><br><span class="line">path  要拓展的文件</span><br><span class="line">length 要拓展的长度</span><br></pre></td></tr></table></figure>



<h2 id="8-linux进程间通信之共享内存"><a href="#8-linux进程间通信之共享内存" class="headerlink" title="8 linux进程间通信之共享内存"></a>8 linux进程间通信之共享内存</h2><h4 id="8-1-共享内存原理"><a href="#8-1-共享内存原理" class="headerlink" title="8.1 共享内存原理"></a>8.1 共享内存原理</h4><p>共享内存允许两个或者多个进程共享给定的存储区域。<br>共享内存的特点<br>1、共享内存是进程间共享数据的一种最快的方法。<br>        一个进程向共享的内存区域写入了数据，共享这个内存区域的所有进程就可以立刻看到其中的内容。<br>2、使用共享内存要注意的是多个进程之间对一个给定存储区访问的互斥。<br>        若一个进程正在向共享内存区写数据，则在它做完这一步操作前，别的进程不应当去读、写这些数据。</p>
<p><strong>共享内存示意图:</strong></p>
<p><img src="/2019/11/03/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/assets%5C1562232892227.png" alt="1562232892227"></p>
<p>在ubuntu 部分版本中共享内存限制值如下<br>共享存储区的最小字节数：1<br>共享存储区的最大字节数：32M<br>共享存储区的最大个数：4096<br>每个进程最多能映射的共享存储区的个数：4096</p>
<h4 id="8-2-共享内存的创建和使用"><a href="#8-2-共享内存的创建和使用" class="headerlink" title="8.2 共享内存的创建和使用"></a>8.2 共享内存的创建和使用</h4><p>获得一个共享存储标识符</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">size_t</span> <span class="built_in">size</span>,<span class="keyword">int</span> shmflg)</span></span>;</span><br><span class="line">	功能:创建或打开一块共享内存区</span><br><span class="line">	参数：</span><br><span class="line">	    key：IPC键值</span><br><span class="line">	    <span class="built_in">size</span>：该共享存储段的长度(字节)</span><br><span class="line">	    shmflg：标识函数的行为及共享内存的权限。</span><br><span class="line">参数:</span><br><span class="line">shmflg：</span><br><span class="line">		IPC_CREAT：如果不存在就创建</span><br><span class="line">		IPC_EXCL：如果已经存在则返回失败</span><br><span class="line">		位或权限位：共享内存位或权限位后可以设置共享内存的访问权限，格式和<span class="built_in">open</span>函数的<span class="keyword">mode_t</span>一样，但可执行权限未使用。</span><br><span class="line">返回值:</span><br><span class="line">成功：返回共享内存标识符。</span><br><span class="line">失败：返回－<span class="number">1</span>。</span><br></pre></td></tr></table></figure>

<p>使用shell命令操作共享内存:<br>    查看共享内存<br>            ipcs -m<br>    删除共享内存<br>            ipcrm -m shmid</p>
<p>共享区映射:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> *<span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">const</span> <span class="keyword">void</span> *shmaddr, </span></span></span><br><span class="line"><span class="function"><span class="params">							<span class="keyword">int</span> shmflg)</span></span>;</span><br><span class="line">	功能：</span><br><span class="line">	    将一个共享内存段映射到调用进程的数据段中。</span><br><span class="line">	参数：</span><br><span class="line">	    shmid：共享内存标识符。</span><br><span class="line">	    shmaddr：共享内存映射地址(若为<span class="literal">NULL</span>则由系	  	  统自动指定)，推荐使用<span class="literal">NULL</span>。</span><br><span class="line"></span><br><span class="line">		shmflg：共享内存段的访问权限和映射条件</span><br><span class="line">		<span class="number">0</span>：共享内存具有可读可写权限。</span><br><span class="line">		SHM_RDONLY：只读。</span><br><span class="line">		SHM_RND：（shmaddr非空时才有效）</span><br><span class="line">	   	没有指定SHM_RND则此段连接到shmaddr所指定的地址上(shmaddr必需页对齐)。</span><br><span class="line">	    指定了SHM_RND则此段连接到shmaddr- shmaddr%SHMLBA 所表示的地址上。</span><br><span class="line">	返回值：</span><br><span class="line">	成功：返回共享内存段映射地址</span><br><span class="line">	失败：返回 <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">	注意:</span><br><span class="line">	   shmat函数使用的时候第二个和第三个参数一般设为<span class="literal">NULL</span>和<span class="number">0</span>，即系统自动指定共享内存地址，并且共享内			存可读可写。</span><br></pre></td></tr></table></figure>

<p>解除共享映射区:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *shmaddr)</span></span>;</span><br><span class="line">	功能：</span><br><span class="line">       将共享内存和当前进程分离(仅仅是断开联系并不删除共享内存)。</span><br><span class="line">	参数：</span><br><span class="line">	shmaddr：共享内存映射地址。</span><br><span class="line">	返回值：</span><br><span class="line">	成功返回 <span class="number">0</span>，失败返回 <span class="number">-1</span>。</span><br></pre></td></tr></table></figure>

<p>共享内存控制:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">int</span> cmd, </span></span></span><br><span class="line"><span class="function"><span class="params">					  struct shmid_ds *buf)</span></span>;</span><br><span class="line">	功能：共享内存空间的控制。</span><br><span class="line">	参数：</span><br><span class="line">	shmid：共享内存标识符。</span><br><span class="line">	cmd：函数功能的控制。</span><br><span class="line">	buf：shmid_ds数据类型的地址，用来存放或修改共享内存的属性。</span><br><span class="line"></span><br><span class="line">cmd：函数功能的控制</span><br><span class="line">IPC_RMID：删除。</span><br><span class="line">IPC_SET：设置shmid_ds参数。</span><br><span class="line">IPC_STAT：保存shmid_ds参数。</span><br><span class="line">SHM_LOCK：锁定共享内存段(超级用户)。</span><br><span class="line">SHM_UNLOCK：解锁共享内存段。</span><br><span class="line">返回值：</span><br><span class="line">	    成功返回 <span class="number">0</span>，失败返回 <span class="number">-1</span>。</span><br></pre></td></tr></table></figure>

<p>注意：<br>        SHM_LOCK用于锁定内存，禁止内存交换。并不代表共享内存被锁定后禁止其它进程访问。其真正的意义是：被锁定的内存不允许被交换到虚拟内存中。<br>        这样做的优势在于让共享内存一直处于内存中，从而提高程序性能</p>
<h2 id="9-linux进程间通信之信号"><a href="#9-linux进程间通信之信号" class="headerlink" title="9 linux进程间通信之信号"></a>9 linux进程间通信之信号</h2><h3 id="9-1-信号概述"><a href="#9-1-信号概述" class="headerlink" title="9.1 信号概述"></a>9.1 信号概述</h3><p><strong>信号的概念</strong><br>信号是 Linux 进程间通信的最古老的方式。信号是软件中断，它是在软件层次上对中断机制的一种模拟，是一种异步通信的方式 。信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断，转而处理某一个突发事件。<br>“中断”在我们生活中经常遇到，譬如，我正在房间里打游戏，突然送快递的来了，把正在玩游戏的我给“中断”了，我去签收快递( 处理中断 )，处理完成后，再继续玩我的游戏。<br>这里我们学习的“信号”就是属于这么一种“中断”。我们在终端上敲“Ctrl+c”，就产生一个“中断”，相当于产生一个信号，接着就会处理这么一个“中断任务”（默认的处理方式为中断当前进程）。</p>
<p><strong>信号的特点</strong><br>简单<br>不能携带大量信息<br>满足某个特设条件才发送</p>
<p>信号可以直接进行用户空间进程和内核空间进程的交互，内核进程可以利用它来通知用户空间进程发生了哪些系统事件。<br>一个完整的信号周期包括三个部分：信号的产生，信号在进程中的注册，信号在进程中的注销，执行信号处理函数。如下图所示：</p>
<p><img src="/2019/11/03/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/assets%5C1562235714540.png" alt="1562235714540"></p>
<p>注意：这里信号的产生，注册，注销时信号的内部机制，而不是信号的函数实现。 </p>
<p><strong>信号的编号</strong></p>
<p>Unix早期版本就提供了信号机制，但不可靠，信号可能丢失。Berkeley 和 AT&amp;T都对信号模型做了更改，增加了可靠信号机制。但彼此不兼容。POSIX.1对可靠信号例程进行了标准化。<br>Linux 可使用命令：kill -l（”l” 为字母），查看相应的信号。</p>
<p><img src="/2019/11/03/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/assets%5C1562235818789.png" alt="1562235818789"></p>
<p>不存在编号为0的信号。其中1-31号信号称之为常规信号（也叫普通信号或标准信号），34-64称之为实时信号，驱动编程与硬件相关。名字上区别不大。而前32个名字各不相同。 </p>
<p><strong>Linux常规信号一览表 :</strong></p>
<table>
<thead>
<tr>
<th><strong>编号</strong></th>
<th><strong>信号</strong></th>
<th><strong>对应事件</strong></th>
<th><strong>默认动作</strong></th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIGHUP</td>
<td>用户退出shell时，由该shell启动的所有进程将收到这个信号</td>
<td>终止进程</td>
</tr>
<tr>
<td>2</td>
<td><strong>SIGINT</strong></td>
<td>当用户按下了<strong>&lt;Ctrl+C&gt;</strong>组合键时，用户终端向正在运行中的由该终端启动的程序发出此信号</td>
<td>终止进程</td>
</tr>
<tr>
<td>3</td>
<td><strong>SIGQUIT</strong></td>
<td>用户按下<strong>&lt;ctrl+&gt;</strong>组合键时产生该信号，用户终端向正在运行中的由该终端启动的程序发出些信号</td>
<td>终止进程</td>
</tr>
<tr>
<td>4</td>
<td>SIGILL</td>
<td>CPU检测到某进程执行了非法指令</td>
<td>终止进程并产生core文件</td>
</tr>
<tr>
<td>5</td>
<td>SIGTRAP</td>
<td>该信号由断点指令或其他 trap指令产生</td>
<td>终止进程并产生core文件</td>
</tr>
<tr>
<td>6</td>
<td>SIGABRT</td>
<td>调用abort函数时产生该信号</td>
<td>终止进程并产生core文件</td>
</tr>
<tr>
<td>7</td>
<td>SIGBUS</td>
<td>非法访问内存地址，包括内存对齐出错</td>
<td>终止进程并产生core文件</td>
</tr>
<tr>
<td>8</td>
<td>SIGFPE</td>
<td>在发生致命的运算错误时发出。不仅包括浮点运算错误，还包括溢出及除数为0等所有的算法错误</td>
<td>终止进程并产生core文件</td>
</tr>
<tr>
<td>9</td>
<td>SIGKILL</td>
<td>无条件终止进程。本信号不能被忽略，处理和阻塞</td>
<td>终止进程，可以杀死任何进程</td>
</tr>
<tr>
<td>10</td>
<td>SIGUSE1</td>
<td>用户定义的信号。即程序员可以在程序中定义并使用该信号</td>
<td>终止进程</td>
</tr>
<tr>
<td>11</td>
<td><strong>SIGSEGV</strong></td>
<td>指示进程进行了无效内存访问(段错误)</td>
<td>终止进程并产生core文件</td>
</tr>
<tr>
<td>12</td>
<td>SIGUSR2</td>
<td>另外一个用户自定义信号，程序员可以在程序中定义并使用该信号</td>
<td>终止进程</td>
</tr>
<tr>
<td>13</td>
<td><strong>SIGPIPE</strong></td>
<td>Broken pipe向一个没有读端的管道写数据</td>
<td>终止进程</td>
</tr>
<tr>
<td>14</td>
<td>SIGALRM</td>
<td>定时器超时，超时的时间 由系统调用alarm设置</td>
<td>终止进程</td>
</tr>
<tr>
<td>15</td>
<td>SIGTERM</td>
<td>程序结束信号，与SIGKILL不同的是，该信号可以被阻塞和终止。通常用来要示程序正常退出。执行shell命令Kill时，缺省产生这个信号</td>
<td>终止进程</td>
</tr>
<tr>
<td>16</td>
<td>SIGSTKFLT</td>
<td>Linux早期版本出现的信号，现仍保留向后兼容</td>
<td>终止进程</td>
</tr>
<tr>
<td>17</td>
<td><strong>SIGCHLD</strong></td>
<td>子进程结束时，父进程会收到这个信号</td>
<td>忽略这个信号</td>
</tr>
<tr>
<td>18</td>
<td>SIGCONT</td>
<td>如果进程已停止，则使其继续运行</td>
<td>继续/忽略</td>
</tr>
<tr>
<td>19</td>
<td>SIGSTOP</td>
<td>停止进程的执行。信号不能被忽略，处理和阻塞</td>
<td>为终止进程</td>
</tr>
<tr>
<td>20</td>
<td>SIGTSTP</td>
<td>停止终端交互进程的运行。按下&lt;ctrl+z&gt;组合键时发出这个信号</td>
<td>暂停进程</td>
</tr>
<tr>
<td>21</td>
<td>SIGTTIN</td>
<td>后台进程读终端控制台</td>
<td>暂停进程</td>
</tr>
<tr>
<td>22</td>
<td>SIGTTOU</td>
<td>该信号类似于SIGTTIN，在后台进程要向终端输出数据时发生</td>
<td>暂停进程</td>
</tr>
<tr>
<td>23</td>
<td>SIGURG</td>
<td>套接字上有紧急数据时，向当前正在运行的进程发出些信号，报告有紧急数据到达。如网络带外数据到达</td>
<td>忽略该信号</td>
</tr>
<tr>
<td>24</td>
<td>SIGXCPU</td>
<td>进程执行时间超过了分配给该进程的CPU时间 ，系统产生该信号并发送给该进程</td>
<td>终止进程</td>
</tr>
<tr>
<td>25</td>
<td>SIGXFSZ</td>
<td>超过文件的最大长度设置</td>
<td>终止进程</td>
</tr>
<tr>
<td>26</td>
<td>SIGVTALRM</td>
<td>虚拟时钟超时时产生该信号。类似于SIGALRM，但是该信号只计算该进程占用CPU的使用时间</td>
<td>终止进程</td>
</tr>
<tr>
<td>27</td>
<td>SGIPROF</td>
<td>类似于SIGVTALRM，它不公包括该进程占用CPU时间还包括执行系统调用时间</td>
<td>终止进程</td>
</tr>
<tr>
<td>28</td>
<td>SIGWINCH</td>
<td>窗口变化大小时发出</td>
<td>忽略该信号</td>
</tr>
<tr>
<td>29</td>
<td>SIGIO</td>
<td>此信号向进程指示发出了一个异步IO事件</td>
<td>忽略该信号</td>
</tr>
<tr>
<td>30</td>
<td>SIGPWR</td>
<td>关机</td>
<td>终止进程</td>
</tr>
<tr>
<td>31</td>
<td>SIGSYS</td>
<td>无效的系统调用</td>
<td>终止进程并产生core文件</td>
</tr>
<tr>
<td>34~64</td>
<td>SIGRTMIN ～ SIGRTMAX</td>
<td>LINUX的实时信号，它们没有固定的含义（可以由用户自定义）</td>
<td>终止进程</td>
</tr>
</tbody></table>
<p><strong>信号的四要素</strong></p>
<p>每个信号必备4要素，分别是：<br>1）编号 2）名称 3）事件 4）默认处理动作<br>可通过man 7 signal查看帮助文档获取：</p>
<p><img src="/2019/11/03/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/assets%5C1562235949570.png" alt="1562235949570"></p>
<p>在标准信号中，有一些信号是有三个“Value”，第一个值通常对alpha和sparc架构有效，中间值针对x86、arm和其他架构，最后一个应用于mips架构。一个‘-’表示在对应架构上尚未定义该信号。<br>不同的操作系统定义了不同的系统信号。因此有些信号出现在Unix系统内，也出现在Linux中，而有的信号出现在FreeBSD或Mac OS中却没有出现在Linux下。这里我们只研究Linux系统中的信号。</p>
<p>Action为默认动作：<br>Term：终止进程<br>Ign： 忽略信号 (默认即时对该种信号忽略操作)<br>Core：终止进程，生成Core文件。(查验死亡原因，用于gdb调试)<br>Stop：停止（暂停）进程<br>Cont：继续运行进程<br>注意通过man 7 signal命令查看帮助文档，其中可看到 : The signals SIGKILL and SIGSTOP cannot be caught, blocked, or ignored.<br>这里特别强调了9) SIGKILL 和19) SIGSTOP信号，不允许忽略和捕捉，只能执行默认动作。甚至不能将其设置为阻塞。<br>另外需清楚，只有每个信号所对应的事件发生了，该信号才会被递送(但不一定递达)，不应乱发信号！！</p>
<h3 id="9-2-信号的产生与动作"><a href="#9-2-信号的产生与动作" class="headerlink" title="9.2 信号的产生与动作"></a>9.2 信号的产生与动作</h3><p><strong>产生</strong><br>a) 当用户按某些终端键时，将产生信号。<br>终端上按“Ctrl+c”组合键通常产生中断信号 SIGINT<br>终端上按“Ctrl+\”键通常产生中断信号 SIGQUIT<br>终端上按“Ctrl+z”键通常产生中断信号 SIGSTOP 等。<br>b) 硬件异常将产生信号。<br>除数为 0，无效的内存访问等。这些情况通常由硬件检测到，并通知内核，然后内核产生适当的信号发送给相应的进程。<br>c) 软件异常将产生信号。<br>当检测到某种软件条件已发生(如：定时器alarm)，并将其通知有关进程时，产生信号。<br>d) 调用系统函数(如：kill、raise、abort)将发送信号。<br>注意：接收信号进程和发送信号进程的所有者必须相同，或发送信号进程的所有者必须是超级用户。<br>e) 运行 kill /killall命令将发送信号。<br>此程序实际上是使用 kill 函数来发送信号。也常用此命令终止一个失控的后台进程。</p>
<h3 id="9-3-未决信号集合信号阻塞集"><a href="#9-3-未决信号集合信号阻塞集" class="headerlink" title="9.3 未决信号集合信号阻塞集"></a>9.3 未决信号集合信号阻塞集</h3><p>信号的实现手段导致信号有很强的延时性，但对于用户来说，时间非常短，不易察觉。<br>Linux内核的进程控制块PCB是一个结构体，task_struct, 除了包含进程id，状态，工作目录，用户id，组id，文件描述符表，还包含了信号相关的信息，主要指阻塞信号集和未决信号集。<br>6.1 阻塞信号集(信号屏蔽字)<br>将某些信号加入集合，对他们设置屏蔽，当屏蔽x信号后，再收到该信号，该信号的处理将推后(处理发生在解除屏蔽后)。<br>6.2 未决信号集<br>信号产生，未决信号集中描述该信号的位立刻翻转为1，表示信号处于未决状态。当信号被处理对应位翻转回为0。这一时刻往往非常短暂。<br>信号产生后由于某些原因(主要是阻塞)不能抵达。这类信号的集合称之为未决信号集。在屏蔽解除前，信号一直处于未决状态。</p>
<h3 id="9-4-发送信号API"><a href="#9-4-发送信号API" class="headerlink" title="9.4 发送信号API"></a>9.4 发送信号API</h3><p><strong>9.4.1 kill函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> sig)</span></span>;</span><br><span class="line">功能：给指定进程发送指定信号(不一定杀死)</span><br><span class="line">参数：</span><br><span class="line">    pid : 取值有 <span class="number">4</span> 种情况 :</span><br><span class="line">        pid &gt; <span class="number">0</span>:  将信号传送给进程 ID 为pid的进程。</span><br><span class="line">        pid = <span class="number">0</span> :  将信号传送给当前进程所在进程组中的所有进程。</span><br><span class="line">        pid = <span class="number">-1</span> : 将信号传送给系统内所有的进程。</span><br><span class="line">        pid &lt; <span class="number">-1</span> : 将信号传给指定进程组的所有进程。这个进程组号等于 pid 的绝对值。</span><br><span class="line">    sig : 信号的编号，这里可以填数字编号，也可以填信号的宏定义，可以通过命令 kill - l(<span class="string">"l"</span> 为字母)进行相应查看。不推荐直接使用数字，应使用宏名，因为不同操作系统信号编号可能不同，但名称一致。</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>super用户(root)可以发送信号给任意用户，普通用户是不能向系统用户发送信号的。<br>kill -9 (root用户的pid) 是不可以的。同样，普通用户也不能向其他普通用户发送信号，终止其进程。 只能向自己创建的进程发送信号。<br>普通用户基本规则是：发送者实际或有效用户ID == 接收者实际或有效用户ID</p>
<p>示例代码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;<span class="comment">//子进程</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"in son process\n"</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;<span class="comment">//父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"in father process\n"</span>);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"kill sub process now \n"</span>);</span><br><span class="line">        kill(pid, SIGINT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>9.4.2 raise函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raise</span><span class="params">(<span class="keyword">int</span> sig)</span></span>;</span><br><span class="line">功能：给当前进程发送指定信号(自己给自己发)，等价于 kill(getpid(), sig)</span><br><span class="line">参数：</span><br><span class="line">    sig：信号编号</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>值</span><br></pre></td></tr></table></figure>

<p><strong>9.4.3 abort函数</strong> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">abort</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">功能：给自己发送异常终止信号 <span class="number">6</span>) SIGABRT，并产生core文件，等价于kill(getpid(), SIGABRT);</span><br><span class="line">参数：无</span><br><span class="line">返回值：无</span><br></pre></td></tr></table></figure>

<p><strong>9.4.4 alarm函数(闹钟)</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">alarm</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span></span>;</span><br><span class="line">功能：</span><br><span class="line">    设置定时器(闹钟)。在指定seconds后，内核会给当前进程发送<span class="number">14</span>）SIGALRM信号。进程收到该信号，默认动作终止。每个进程都有且只有唯一的一个定时器。</span><br><span class="line">    取消定时器alarm(<span class="number">0</span>)，返回旧闹钟余下秒数。</span><br><span class="line">参数：</span><br><span class="line">    seconds：指定的时间，以秒为单位</span><br><span class="line">返回值：</span><br><span class="line">    返回<span class="number">0</span>或剩余的秒数</span><br></pre></td></tr></table></figure>

<p>定时，与进程状态无关(自然定时法)！就绪、运行、挂起(阻塞、暂停)、终止、僵尸……无论进程处于何种状态，alarm都计时。 </p>
<p>测试程序:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> seconds = <span class="number">0</span>;</span><br><span class="line">    seconds = alarm(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"seconds = %d\n"</span>, seconds);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    seconds = alarm(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"seconds = %d\n"</span>, seconds);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>9.4.5 setitimer函数（定时器）</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setitimer</span><span class="params">(<span class="keyword">int</span> which,  <span class="keyword">const</span> struct itimerval *new_value, struct itimerval *old_value)</span></span>;</span><br><span class="line">功能：</span><br><span class="line">    设置定时器(闹钟)。 可代替alarm函数。精度微秒us，可以实现周期定时。</span><br><span class="line">参数：</span><br><span class="line">    which：指定定时方式</span><br><span class="line">        a) 自然定时：ITIMER_REAL → <span class="number">14</span>）SIGALRM计算自然时间</span><br><span class="line">        b) 虚拟空间计时(用户空间)：ITIMER_VIRTUAL → <span class="number">26</span>）SIGVTALRM  只计算进程占用cpu的时间</span><br><span class="line">        c) 运行时计时(用户 + 内核)：ITIMER_PROF → <span class="number">27</span>）SIGPROF计算占用cpu及执行系统调用的时间</span><br><span class="line">    new_value：<span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span>, 负责设定<span class="title">timeout</span>时间</span></span><br><span class="line"><span class="class">        <span class="title">struct</span> <span class="title">itimerval</span> &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">timerval</span> <span class="title">it_interval</span>;</span> <span class="comment">// 闹钟触发周期</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">timerval</span> <span class="title">it_value</span>;</span>    <span class="comment">// 闹钟触发时间</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">            <span class="keyword">long</span> tv_sec;            <span class="comment">// 秒</span></span><br><span class="line">            <span class="keyword">long</span> tv_usec;           <span class="comment">// 微秒</span></span><br><span class="line">        &#125;</span><br><span class="line">        itimerval.it_value： 设定第一次执行function所延迟的秒数 </span><br><span class="line">        itimerval.it_interval：  设定以后每几秒执行function</span><br><span class="line">    old_value： 存放旧的timeout值，一般指定为<span class="literal">NULL</span></span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>示例程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfunc</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">new_value</span>;</span></span><br><span class="line">    <span class="comment">//定时周期</span></span><br><span class="line">    new_value.it_interval.tv_sec = <span class="number">1</span>;</span><br><span class="line">    new_value.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//第一次触发的时间</span></span><br><span class="line">    new_value.it_value.tv_sec = <span class="number">2</span>;</span><br><span class="line">    new_value.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line">    signal(SIGALRM, myfunc); <span class="comment">//信号处理</span></span><br><span class="line">    setitimer(ITIMER_REAL, &amp;new_value, <span class="literal">NULL</span>); <span class="comment">//定时器设置</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="9-5-修改信号的处理动作"><a href="#9-5-修改信号的处理动作" class="headerlink" title="9.5 修改信号的处理动作"></a>9.5 修改信号的处理动作</h3><p><strong>9.6.1 信号处理方式</strong><br>一个进程收到一个信号的时候，可以用如下方法进行处理：<br>1）执行系统默认动作<br>对大多数信号来说，系统默认动作是用来终止该进程。<br>2）忽略此信号(丢弃)<br>接收到此信号后没有任何动作。<br>3）执行自定义信号处理函数(捕获)<br>用用户定义的信号处理函数处理该信号。<br>【注意】：SIGKILL 和 SIGSTOP 不能更改信号的处理方式，因为它们向用户提供了一种使进程终止的可靠方法。</p>
<p>内核实现信号捕捉过程： </p>
<p><img src="/2019/11/03/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/assets%5C1562237717322.png" alt="1562237717322"></p>
<p>捕捉信号并且信号信号的处理方式有两个函数,signal 和sigaction</p>
<p><strong>9.6.2 signal函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">sighandler_t</span> signal(<span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> handler);</span><br><span class="line">功能：</span><br><span class="line">    注册信号处理函数（不可用于 SIGKILL、SIGSTOP 信号），即确定收到信号后处理函数的入口地址。此函数不会阻塞。</span><br><span class="line">参数：</span><br><span class="line">    signum：信号的编号，这里可以填数字编号，也可以填信号的宏定义，可以通过命令 kill - l(<span class="string">"l"</span> 为字母)进行相应查看。</span><br><span class="line">    handler : 取值有 <span class="number">3</span> 种情况：</span><br><span class="line">          SIG_IGN：忽略该信号</span><br><span class="line">          SIG_DFL：执行系统默认动作</span><br><span class="line">          信号处理函数名：自定义信号处理函数，如：func</span><br><span class="line">          回调函数的定义如下：</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="comment">// signo 为触发的信号，为 signal() 第一个参数的值</span></span><br><span class="line">            &#125;</span><br><span class="line">返回值：</span><br><span class="line">    成功：第一次返回 <span class="literal">NULL</span>，下一次返回此信号上一次注册的信号处理函数的地址。如果需要使用此返回值，必须在前面先声明此函数指针的类型。</span><br><span class="line">    失败：返回 SIG_ERR</span><br></pre></td></tr></table></figure>

<p>该函数由ANSI定义，由于历史原因在不同版本的Unix和不同版本的Linux中可能有不同的行为。因此应该尽量避免使用它，取而代之使用sigaction函数。</p>
<p>代码示例:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 信号处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal_handler</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (signo == SIGINT)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"recv SIGINT\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (signo == SIGQUIT)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"recv SIGQUIT\n"</span>);</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"wait for SIGINT OR SIGQUIT\n"</span>);</span><br><span class="line">    <span class="comment">/* SIGINT: Ctrl+c ; SIGQUIT: Ctrl+\ */</span></span><br><span class="line">    <span class="comment">// 信号注册函数</span></span><br><span class="line">    signal(SIGINT, signal_handler);</span><br><span class="line">    signal(SIGQUIT, signal_handler);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>); <span class="comment">//不让程序结束</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>9.6.3 sigaction函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">const</span> struct sigaction *act, struct sigaction *oldact)</span></span>;</span><br><span class="line">功能：</span><br><span class="line">    检查或修改指定信号的设置（或同时执行这两种操作）。</span><br><span class="line">参数：</span><br><span class="line">    signum：要操作的信号。</span><br><span class="line">    act：   要设置的对信号的新处理方式（传入参数）。</span><br><span class="line">    oldact：原来对信号的处理方式（传出参数）。</span><br><span class="line">    如果 act 指针非空，则要改变指定信号的处理方式（设置），如果 oldact 指针非空，则系统将此前指定信号的处理方式存入 oldact。</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>struct sigaction结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span>(*sa_handler)(<span class="keyword">int</span>); <span class="comment">//旧的信号处理函数指针</span></span><br><span class="line">    <span class="keyword">void</span>(*sa_sigaction)(<span class="keyword">int</span>, <span class="keyword">siginfo_t</span> *, <span class="keyword">void</span> *); <span class="comment">//新的信号处理函数指针</span></span><br><span class="line">    <span class="keyword">sigset_t</span>   sa_mask;      <span class="comment">//信号阻塞集</span></span><br><span class="line">    <span class="keyword">int</span>        sa_flags;     <span class="comment">//信号处理的方式</span></span><br><span class="line">    <span class="keyword">void</span>(*sa_restorer)(<span class="keyword">void</span>); <span class="comment">//已弃用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>1) sa_handler、sa_sigaction：信号处理函数指针，和 signal() 里的函数指针用法一样，应根据情况给sa_sigaction、sa_handler 两者之一赋值，其取值如下：<br>a) SIG_IGN：忽略该信号<br>b) SIG_DFL：执行系统默认动作<br>c) 处理函数名：自定义信号处理函数<br>2) sa_mask：信号阻塞集，在信号处理函数执行过程中，临时屏蔽指定的信号。<br>3) sa_flags：用于指定信号处理的行为，通常设置为0，表使用默认属性。它可以是一下值的“按位或”组合：<br>Ø SA_RESTART：使被信号打断的系统调用自动重新发起（已经废弃）<br>Ø SA_NOCLDSTOP：使父进程在它的子进程暂停或继续运行时不会收到 SIGCHLD 信号。<br>Ø SA_NOCLDWAIT：使父进程在它的子进程退出时不会收到 SIGCHLD 信号，这时子进程如果退出也不会成为僵尸进程。<br>Ø SA_NODEFER：使对信号的屏蔽无效，即在信号处理函数执行期间仍能发出这个信号。<br>Ø SA_RESETHAND：信号处理之后重新设置为默认的处理方式。<br>Ø SA_SIGINFO：使用 sa_sigaction 成员而不是 sa_handler 作为信号处理函数。</p>
<p>信号处理函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>(*sa_sigaction)(<span class="keyword">int</span> signum, <span class="keyword">siginfo_t</span> *info, <span class="keyword">void</span> *context);</span><br><span class="line">参数说明：</span><br><span class="line">    signum：信号的编号。</span><br><span class="line">    info：记录信号发送进程信息的结构体。</span><br><span class="line">    context：可以赋给指向 <span class="keyword">ucontext_t</span> 类型的一个对象的指针，以引用在传递信号时被中断的接收进程或线程的上下文。</span><br></pre></td></tr></table></figure>



<h3 id="9-6-信号集"><a href="#9-6-信号集" class="headerlink" title="9.6 信号集"></a>9.6 信号集</h3><p><strong>9.6.1 信号集概述</strong></p>
<p>在PCB中有两个非常重要的信号集。一个称之为“阻塞信号集”，另一个称之为“未决信号集”。<br>这两个信号集都是内核使用位图机制来实现的。但操作系统不允许我们直接对其进行位操作。而需自定义另外一个集合，借助信号集操作函数来对PCB中的这两个信号集进行修改。</p>
<p><img src="/2019/11/03/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/assets%5C1562238388218.png" alt="1562238388218"></p>
<p><strong>9.6.2自定义信号集函数</strong></p>
<p>为了方便对多个信号进行处理，一个用户进程常常需要对多个信号做出处理，在 Linux 系统中引入了信号集（信号的集合）。<br>这个信号集有点类似于我们的 QQ 群，一个个的信号相当于 QQ 群里的一个个好友。<br>信号集是一个能表示多个信号的数据类型，sigset_t set，set即一个信号集。既然是一个集合，就需要对集合进行添加/删除等操作。<br>相关函数说明如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;  </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigemptyset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;       <span class="comment">//将set集合置空</span></span><br><span class="line">int sigfillset(sigset_t *set)；          //将所有信号加入set集合</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaddset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signo)</span></span>;  <span class="comment">//将signo信号加入到set集合</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigdelset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signo)</span></span>;   <span class="comment">//从set集合中移除signo信号</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigismember</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signo)</span></span>; <span class="comment">//判断信号是否存在</span></span><br></pre></td></tr></table></figure>

<p>除sigismember外，其余操作函数中的set均为传出参数。sigset_t类型的本质是位图。但不应该直接使用位操作，而应该使用上述函数，保证跨系统操作有效。 </p>
<p>示例程序:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">sigset_t</span> <span class="built_in">set</span>;   <span class="comment">// 定义一个信号集变量</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>); <span class="comment">// 清空信号集的内容</span></span><br><span class="line">    <span class="comment">// 判断 SIGINT 是否在信号集 set 里</span></span><br><span class="line">    <span class="comment">// 在返回 1， 不在返回 0</span></span><br><span class="line">    ret = sigismember(&amp;<span class="built_in">set</span>, SIGINT);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"SIGINT is not a member of set \nret = %d\n"</span>, ret);</span><br><span class="line">    &#125;</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGINT); <span class="comment">// 把 SIGINT 添加到信号集 set</span></span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGQUIT);<span class="comment">// 把 SIGQUIT 添加到信号集 set</span></span><br><span class="line">    <span class="comment">// 判断 SIGINT 是否在信号集 set 里</span></span><br><span class="line">    <span class="comment">// 在返回 1， 不在返回 0</span></span><br><span class="line">    ret = sigismember(&amp;<span class="built_in">set</span>, SIGINT);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"SIGINT is a member of set \nret = %d\n"</span>, ret);</span><br><span class="line">    &#125;</span><br><span class="line">    sigdelset(&amp;<span class="built_in">set</span>, SIGQUIT); <span class="comment">// 把 SIGQUIT 从信号集 set 移除</span></span><br><span class="line">    <span class="comment">// 判断 SIGQUIT 是否在信号集 set 里</span></span><br><span class="line">    <span class="comment">// 在返回 1， 不在返回 0</span></span><br><span class="line">    ret = sigismember(&amp;<span class="built_in">set</span>, SIGQUIT);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"SIGQUIT is not a member of set \nret = %d\n"</span>, ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>9.6.3 sigprocmask函数</strong></p>
<p>信号阻塞集也称信号屏蔽集、信号掩码。每个进程都有一个阻塞集，创建子进程时子进程将继承父进程的阻塞集。信号阻塞集用来描述哪些信号递送到该进程的时候被阻塞（在信号发生时记住它，直到进程准备好时再将信号通知进程）。<br>所谓阻塞并不是禁止传送信号, 而是暂缓信号的传送。若将被阻塞的信号从信号阻塞集中删除，且对应的信号在被阻塞时发生了，进程将会收到相应的信号。<br>我们可以通过 sigprocmask() 修改当前的信号掩码来改变信号的阻塞情况。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigprocmask</span><span class="params">(<span class="keyword">int</span> how, <span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">sigset_t</span> *oldset)</span></span>;</span><br><span class="line">功能：</span><br><span class="line">    检查或修改信号阻塞集，根据 how 指定的方法对进程的阻塞集合进行修改，新的信号阻塞集由 <span class="built_in">set</span> 指定，而原先的信号阻塞集合由 oldset 保存。</span><br><span class="line">参数：</span><br><span class="line">    how : 信号阻塞集合的修改方法，有 <span class="number">3</span> 种情况：</span><br><span class="line">        SIG_BLOCK：向信号阻塞集合中添加 <span class="built_in">set</span> 信号集，新的信号掩码是<span class="built_in">set</span>和旧信号掩码的并集。相当于 mask = mask|<span class="built_in">set</span>。</span><br><span class="line">        SIG_UNBLOCK：从信号阻塞集合中删除 <span class="built_in">set</span> 信号集，从当前信号掩码中去除 <span class="built_in">set</span> 中的信号。相当于 mask = mask &amp; ~ <span class="built_in">set</span>。</span><br><span class="line">        SIG_SETMASK：将信号阻塞集合设为 <span class="built_in">set</span> 信号集，相当于原来信号阻塞集的内容清空，然后按照 <span class="built_in">set</span> 中的信号重新设置信号阻塞集。相当于mask = <span class="built_in">set</span>。</span><br><span class="line">    <span class="built_in">set</span> : 要操作的信号集地址。</span><br><span class="line">        若 <span class="built_in">set</span> 为 <span class="literal">NULL</span>，则不改变信号阻塞集合，函数只把当前信号阻塞集合保存到 oldset 中。</span><br><span class="line">    oldset : 保存原先信号阻塞集地址</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span>，</span><br><span class="line">    失败：<span class="number">-1</span>，失败时错误代码只可能是 EINVAL，表示参数 how 不合法。</span><br></pre></td></tr></table></figure>

<p><strong>9.6.4 sigpending函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigpending</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;</span><br><span class="line">功能：读取当前进程的未决信号集</span><br><span class="line">参数：</span><br><span class="line">    <span class="built_in">set</span>：未决信号集</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>示例代码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 自定义信号集</span></span><br><span class="line">    <span class="keyword">sigset_t</span> myset, old;</span><br><span class="line">    sigemptyset(&amp;myset);<span class="comment">// 清空　－》　0</span></span><br><span class="line">    <span class="comment">// 添加要阻塞的信号</span></span><br><span class="line">    sigaddset(&amp;myset, SIGINT);</span><br><span class="line">    sigaddset(&amp;myset, SIGQUIT);</span><br><span class="line">    sigaddset(&amp;myset, SIGKILL);</span><br><span class="line">    <span class="comment">// 自定义信号集设置到内核中的阻塞信号集</span></span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;myset, &amp;old);</span><br><span class="line">    <span class="keyword">sigset_t</span> pend;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 读内核中的未决信号集的状态</span></span><br><span class="line">        sigpending(&amp;pend);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;<span class="number">32</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (sigismember(&amp;pend, i))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"1"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sigismember(&amp;pend, i) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        i++;</span><br><span class="line">        <span class="comment">// 10s之后解除阻塞</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// sigprocmask(SIG_UNBLOCK, &amp;myset, NULL);</span></span><br><span class="line">            sigprocmask(SIG_SETMASK, &amp;old, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h2 id="10-linux多任务编程之线程"><a href="#10-linux多任务编程之线程" class="headerlink" title="10 linux多任务编程之线程"></a>10 linux多任务编程之线程</h2><h3 id="10-1-线程概述"><a href="#10-1-线程概述" class="headerlink" title="10.1 线程概述"></a>10.1 线程概述</h3><p>在许多经典的操作系统教科书中，总是把进程定义为程序的执行实例，它并不执行什么, 只是维护应用程序所需的各种资源，而线程则是真正的执行实体。<br>所以，线程是轻量级的进程（LWP：light weight process），在Linux环境下线程的本质仍是进程。<br>为了让进程完成一定的工作，进程必须至少包含一个线程。</p>
<p><img src="/2019/11/03/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/assets%5C1562239158898.png" alt="1562239158898"></p>
<p>进程，直观点说，保存在硬盘上的程序运行以后，会在内存空间里形成一个独立的内存体，这个内存体有自己的地址空间，有自己的堆，上级挂靠单位是操作系统。操作系统会以进程为单位，分配系统资源，所以我们也说，进程是CPU分配资源的最小单位。<br>线程存在与进程当中(进程可以认为是线程的容器)，是操作系统调度执行的最小单位。说通俗点，线程就是干活的。<br>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。<br>线程是进程的一个实体，是 CPU 调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。<br>如果说进程是一个资源管家，负责从主人那里要资源的话，那么线程就是干活的苦力。一个管家必须完成一项工作，就需要最少一个苦力，也就是说，一个进程最少包含一个线程，也可以包含多个线程。苦力要干活，就需要依托于管家，所以说一个线程，必须属于某一个进程。<br>进程有自己的地址空间，线程使用进程的地址空间，也就是说，进程里的资源，线程都是有权访问的，比如说堆啊，栈啊，静态存储区什么的。</p>
<blockquote>
<p>进程是操作系统分配资源的最小单位</p>
<p>线程是操作系统调度的最小单位</p>
</blockquote>
<p><strong>线程函数列表安装</strong></p>
<p>命令：</p>
<blockquote>
<p>sudo apt-get install manpages-posix-dev </p>
</blockquote>
<p>【说明】manpages-posix-dev 包含 POSIX 的 header files 和 library calls 的用法</p>
<p>查看：</p>
<blockquote>
<p>man -k pthread</p>
</blockquote>
<p><strong>线程的特点:</strong></p>
<p>类Unix系统中，早期是没有“线程”概念的，80年代才引入，借助进程机制实现出了线程的概念。 </p>
<p>因此在这类系统中，进程和线程关系密切：</p>
<p>1) 线程是轻量级进程(light-weight process)，也有PCB，创建线程使用的底层函数和进程一样，都是clone<br>2) 从内核里看进程和线程是一样的，都有各自不同的PCB.<br>3) 进程可以蜕变成线程<br>4) 在linux下，线程最是小的执行单位；进程是最小的分配资源单位</p>
<p><img src="/2019/11/03/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/assets%5C1562239440165.png" alt="1562239440165"></p>
<p>查看指定进程的LWP号：<br>ps  -Lf  pid<br>实际上，无论是创建进程的fork，还是创建线程的pthread_create，底层实现都是调用同一个内核函数 clone 。<br>Ø 如果复制对方的地址空间，那么就产出一个“进程”；<br>Ø 如果共享对方的地址空间，就产生一个“线程”。<br>Linux内核是不区分进程和线程的, 只在用户层面上进行区分。所以，线程所有操作函数 pthread_* 是库函数，而非系统调用。 </p>
<p><strong>线程共享资源</strong></p>
<p>1) 文件描述符表<br>2) 每种信号的处理方式<br>3) 当前工作目录<br>4) 用户ID和组ID<br>内存地址空间 (.text/.data/.bss/heap/共享库)</p>
<p><strong>线程非共享资源</strong></p>
<p>1) 线程id<br>2) 处理器现场和栈指针(内核栈)<br>3) 独立的栈空间(用户空间栈)<br>4) errno变量<br>5) 信号屏蔽字<br>6) 调度优先级</p>
<p><strong>线程的优缺点</strong></p>
<p>优点：<br>Ø 提高程序并发性<br>Ø 开销小<br>Ø 数据通信、共享数据方便</p>
<p>缺点：<br>Ø 库函数，不稳定<br>Ø 调试、编写困难、gdb不支持<br>Ø 对信号支持不好<br>优点相对突出，缺点均不是硬伤。Linux下由于实现方法导致进程、线程差别不是很大。</p>
<p><strong>线程号</strong></p>
<p>就像每个进程都有一个进程号一样，每个线程也有一个线程号。进程号在整个系统中是唯一的，但线程号不同，线程号只在它所属的进程环境中有效。<br>进程号用 pid_t 数据类型表示，是一个非负整数。线程号则用 pthread_t 数据类型来表示，Linux 使用无符号长整数表示。<br>有的系统在实现pthread_t 的时候，用一个结构体来表示，所以在可移植的操作系统实现不能把它做为整数处理。</p>
<p>获取线程号pthread_self函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">pthread_t</span> pthread_self(<span class="keyword">void</span>);</span><br><span class="line">功能：</span><br><span class="line">    获取线程号。</span><br><span class="line">参数：</span><br><span class="line">    无</span><br><span class="line">返回值：</span><br><span class="line">    调用线程的线程 ID 。</span><br></pre></td></tr></table></figure>

<h3 id="10-2-线程的创建"><a href="#10-2-线程的创建" class="headerlink" title="10.2 线程的创建"></a>10.2 线程的创建</h3><p>pthread_create函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span> *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">void</span> *(*start_routine)(<span class="keyword">void</span> *),</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">void</span> *arg )</span></span>;</span><br><span class="line">功能：</span><br><span class="line">    创建一个线程</span><br><span class="line">参数：</span><br><span class="line">    thread：线程标识符地址。</span><br><span class="line">    attr：线程属性结构体地址，通常设置为 <span class="literal">NULL</span>。</span><br><span class="line">    start_routine：线程函数的入口地址。</span><br><span class="line">    arg：传给线程函数的参数。</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非 <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>在一个线程中调用pthread_create()创建新的线程后，当前线程从pthread_create()返回继续往下执行，而新的线程所执行的代码由我们传给pthread_create的函数指针start_routine决定。<br>由于pthread_create的错误码不保存在errno中，因此不能直接用perror()打印错误信息，可以先用strerror()把错误码转换成错误信息再打印。</p>
<p>示例程序:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> num =<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">pthid1_callback</span><span class="params">(<span class="keyword">void</span> *agr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		num++;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"i am pth 1  run\n"</span>);</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">pthid2_callback</span><span class="params">(<span class="keyword">void</span> *agr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"i am pth 2  run num=%d\n"</span>,num);</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pthread_t</span> pthid1,pthid2;</span><br><span class="line">	<span class="comment">//创建线程</span></span><br><span class="line">	pthread_create(&amp;pthid1,<span class="literal">NULL</span>,pthid1_callback,<span class="literal">NULL</span>);</span><br><span class="line">	pthread_create(&amp;pthid2,<span class="literal">NULL</span>,pthid2_callback,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-3-回收线程资源"><a href="#10-3-回收线程资源" class="headerlink" title="10.3 回收线程资源"></a>10.3 回收线程资源</h3><p>pthread_join函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">void</span> **retval)</span></span>;</span><br><span class="line">功能：</span><br><span class="line">    等待线程结束（此函数会阻塞），并回收线程资源，类似进程的 wait() 函数。如果线程已经结束，那么该函数会立即返回。</span><br><span class="line">参数：</span><br><span class="line">    thread：被等待的线程号。</span><br><span class="line">    retval：用来存储线程退出状态的指针的地址</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非 <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>示例代码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> num =<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">pthid1_callback</span><span class="params">(<span class="keyword">void</span> *agr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		num++;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"i am pth 1  run\n"</span>);</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">pthid2_callback</span><span class="params">(<span class="keyword">void</span> *agr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"i am pth 2  run num=%d\n"</span>,num);</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pthread_t</span> pthid1,pthid2;</span><br><span class="line">	<span class="comment">//创建线程</span></span><br><span class="line">	pthread_create(&amp;pthid1,<span class="literal">NULL</span>,pthid1_callback,<span class="literal">NULL</span>);</span><br><span class="line">	pthread_create(&amp;pthid2,<span class="literal">NULL</span>,pthid2_callback,<span class="literal">NULL</span>);</span><br><span class="line">	pthread_join(pthid1,<span class="literal">NULL</span>);<span class="comment">//等5s 阻塞</span></span><br><span class="line">	pthread_join(pthid2,<span class="literal">NULL</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>线程分离pthread_detach</strong></p>
<p>一般情况下，线程终止后，其终止状态一直保留到其它线程调用pthread_join获取它的状态为止。但是线程也可以被置为detach状态，这样的线程一旦终止就立刻回收它占用的所有资源，而不保留终止状态。<br>不能对一个已经处于detach状态的线程调用pthread_join，这样的调用将返回EINVAL错误。也就是说，如果已经对一个线程调用了pthread_detach就不能再调用pthread_join了。</p>
<p>pthread_detach函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span>;</span><br><span class="line">功能：</span><br><span class="line">    使调用线程与当前进程分离，分离后不代表此线程不依赖与当前进程，线程分离的目的是将线程资源的回收工作交由系统自动来完成，也就是说当被分离的线程结束之后，系统会自动回收它的资源。所以，此函数不会阻塞</span><br><span class="line">参数：</span><br><span class="line">    thread：线程号。</span><br><span class="line">返回值:</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span></span><br></pre></td></tr></table></figure>

<h3 id="10-4-线程的退出和取消"><a href="#10-4-线程的退出和取消" class="headerlink" title="10.4 线程的退出和取消"></a>10.4 线程的退出和取消</h3><p><strong>线程的退出:</strong></p>
<p>在进程中我们可以调用exit函数或_exit函数来结束进程，在一个线程中我们可以通过以下三种在不终止整个进程的情况下停止它的控制流。<br>线程从执行函数中返回。<br>线程调用pthread_exit退出线程。<br>线程可以被同一进程中的其它线程取消。</p>
<p>pthread_exit函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span> *retval)</span></span>;</span><br><span class="line">功能：</span><br><span class="line">    退出调用线程。一个进程中的多个线程是共享该进程的数据段，因此，通常线程退出后所占用的资源并不会释放。</span><br><span class="line">参数：</span><br><span class="line">    retval：存储线程退出状态的指针。</span><br><span class="line">返回值：无</span><br></pre></td></tr></table></figure>

<p>示例代码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">callback</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"hello world\n"</span>);</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span>(<span class="number">50</span> == i++)</span><br><span class="line">			pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pthread_t</span> pthid;</span><br><span class="line">	pthread_create(&amp;pthid,<span class="literal">NULL</span>,callback,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"join\n"</span>);</span><br><span class="line">	pthread_join(pthid,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"join ok\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>线程取消</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">int pthread_cancel(pthread_t thread);</span><br><span class="line">功能：</span><br><span class="line">    杀死(取消)线程</span><br><span class="line">参数：</span><br><span class="line">    thread : 目标线程ID。</span><br><span class="line">返回值：</span><br><span class="line">    成功：0</span><br><span class="line">    失败：出错编号</span><br></pre></td></tr></table></figure>

<p>注意：线程的取消并不是实时的，而又一定的延时。需要等待线程到达某个取消点(检查点)。<br>类似于玩游戏存档，必须到达指定的场所(存档点，如：客栈、仓库、城里等)才能存储进度。<br>杀死线程也不是立刻就能完成，必须要到达取消点。<br>取消点：是线程检查是否被取消，并按请求进行动作的一个位置。通常是一些系统调用creat，open，pause，close，read，write….. 执行命令man 7 pthreads可以查看具备这些取消点的系统调用列表。<br>可粗略认为一个系统调用(进入内核)即为一个取消点。 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_cancel</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_testcancel(); <span class="comment">//设置取消点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, thread_cancel, <span class="literal">NULL</span>); <span class="comment">//创建线程</span></span><br><span class="line">    sleep(<span class="number">3</span>);                   <span class="comment">//3秒后</span></span><br><span class="line">    pthread_cancel(tid); <span class="comment">//取消tid线程</span></span><br><span class="line">    pthread_join(tid, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="10-5-线程的属性-了解"><a href="#10-5-线程的属性-了解" class="headerlink" title="10.5 线程的属性(了解)"></a>10.5 线程的属性(了解)</h3><p>Linux下线程的属性是可以根据实际项目需要，进行设置，之前我们讨论的线程都是采用线程的默认属性，默认属性已经可以解决绝大多数开发时遇到的问题。<br>如我们对程序的性能提出更高的要求那么需要设置线程属性，比如可以通过设置线程栈的大小来降低内存的使用，增加最大线程个数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> 			etachstate; 	<span class="comment">//线程的分离状态</span></span><br><span class="line"><span class="keyword">int</span> 			schedpolicy; 	<span class="comment">//线程调度策略</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span>	<span class="title">schedparam</span>;</span> 	<span class="comment">//线程的调度参数</span></span><br><span class="line"><span class="keyword">int</span> 			inheritsched; 	<span class="comment">//线程的继承性</span></span><br><span class="line"><span class="keyword">int</span> 			scope; 		<span class="comment">//线程的作用域</span></span><br><span class="line"><span class="keyword">size_t</span> 		guardsize; 	<span class="comment">//线程栈末尾的警戒缓冲区大小</span></span><br><span class="line"><span class="keyword">int</span>			stackaddr_set; <span class="comment">//线程的栈设置</span></span><br><span class="line"><span class="keyword">void</span>* 		stackaddr; 	<span class="comment">//线程栈的位置</span></span><br><span class="line"><span class="keyword">size_t</span> 		stacksize; 	<span class="comment">//线程栈的大小</span></span><br><span class="line">&#125; <span class="keyword">pthread_attr_t</span>;</span><br></pre></td></tr></table></figure>

<p><strong>主要结构体成员：</strong><br>    1. 线程分离状态<br>    2. 线程栈大小（默认平均分配）<br>    3. 线程栈警戒缓冲区大小（位于栈末尾）<br>    4. 线程栈最低地址<br>属性值不能直接设置，须使用相关函数进行操作，初始化的函数为pthread_attr_init，这个函数必须在pthread_create函数之前调用。之后须用pthread_attr_destroy函数来释放资源。<br>线程属性主要包括如下属性：作用域（scope）、栈尺寸（stack size）、栈地址（stack address）、优先级（priority）、分离的状态（detached state）、调度策略和参数（scheduling policy and parameters）。默认的属性为非绑定、非分离、缺省的堆栈、与父进程同样级别的优先级.</p>
<p><strong>线程属性初始化</strong>注意：应先初始化线程属性，再pthread_create创建线程<br>初始化线程属性函数：<br>    int pthread_attr_init(pthread_attr_t <em>attr);<br>    函数返回值：成功：0；失败：错误号<br>销毁线程属性所占用的资源函数：<br>    int pthread_attr_destroy(pthread_attr_t *attr);<br>    函数返回值：成功：0；失败：错误号<br>线程的分离状态<br>线程的分离状态决定一个线程以什么样的方式来终止自己。<br>    非分离状态：线程的默认属性是非分离状态，这种情况下，原有的线程等待创建的线程结束。只有当pthread_join()函数返回时，创建的线程才算终止，才能释放自己占用的系统资源。<br>    分离状态：分离线程没有被其他的线程所等待，自己运行结束了，线程也就终止了，马上释放系统资源。应该根据自己的需要，选择适当的分离状态。<br>线程分离状态的函数：<br>设置线程属性，分离or非分离<br>int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);<br>获取程属性，分离or非分离<br>int pthread_attr_getdetachstate(pthread_attr_t *attr, int *detachstat);<br>参数：<br>    attr：已初始化的线程属性<br>    detachstate：    分离状态<br>    PTHREAD_CREATE_DETACHED（分离线程）<br>    PTHREAD _CREATE_JOINABLE（非分离线程）<br>这里要注意的一点是，如果设置一个线程为分离线程，而这个线程运行又非常快，它很可能在pthread_create函数返回之前就终止了，它终止以后就可能将线程号和系统资源移交给其他的线程使用，这样调用pthread_create的线程就得到了错误的线程号。<br>要避免这种情况可以采取一定的同步措施，最简单的方法之一是可以在被创建的线程里调用pthread_cond_timedwait函数，让这个线程等待一会儿，留出足够的时间让函数pthread_create返回。<br>设置一段等待时间，是在多线程编程里常用的方法。但是注意不要使用诸如wait()之类的函数，它们是使整个进程睡眠，并不能解决线程同步的问题。<br>*</em>线程的栈地址**<br>POSIX.1定义了两个常量_POSIX_THREAD_ATTR_STACKADDR 和_POSIX_THREAD_ATTR_STACKSIZE检测系统是否支持栈属性。也可以给sysconf函数传递_SC_THREAD_ATTR_STACKADDR或 _SC_THREAD_ATTR_STACKSIZE来进行检测。<br>当进程栈地址空间不够用时，指定新建线程使用由malloc分配的空间作为自己的栈空间。通过pthread_attr_setstack和pthread_attr_getstack两个函数分别设置和获取线程的栈地址。<br>int pthread_attr_setstack(pthread_attr_t <em>attr, void *stackaddr, size_t stacksize);<br>成功：0；失败：错误号<br>int pthread_attr_getstack(pthread_attr_t *attr, void *</em>stackaddr, size_t *stacksize); 成功：0；失败：错误号<br>参数：    attr：指向一个线程属性的指针<br>stackaddr：返回获取的栈地址<br>stacksize：返回获取的栈大小<br>线程的栈大小<br>当系统中有很多线程时，可能需要减小每个线程栈的默认大小，防止进程的地址空间不够用,当线程调用的函数会分配很大的局部变量或者函数调用层次很深时，可能需要增大线程栈的默认大小。<br>函数pthread_attr_getstacksize和 pthread_attr_setstacksize提供设置。<br>int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize); 成功：0；失败：错误号<br>int pthread_attr_getstacksize(pthread_attr_t *attr, size_t *stacksize); 成功：0；失败：错误号<br>参数：    attr：指向一个线程属性的指针<br>stacksize：返回线程的堆栈大小</p>
<p>线程属性总和案例:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 0x100000</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">th_fun</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) </span><br><span class="line">	sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pthread_t</span> tid;</span><br><span class="line">	<span class="keyword">int</span> err, detachstate, i = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">	<span class="keyword">size_t</span> stacksize;</span><br><span class="line">	<span class="keyword">void</span> *stackaddr;</span><br><span class="line"></span><br><span class="line">	pthread_attr_init(&amp;attr);		</span><br><span class="line">	pthread_attr_getstack(&amp;attr, &amp;stackaddr, &amp;stacksize);</span><br><span class="line">	pthread_attr_getdetachstate(&amp;attr, &amp;detachstate);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (detachstate == PTHREAD_CREATE_DETACHED)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"thread detached\n"</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (detachstate == PTHREAD_CREATE_JOINABLE)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"thread join\n"</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"thread unknown\n"</span>);</span><br><span class="line"></span><br><span class="line">	pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		stackaddr = <span class="built_in">malloc</span>(SIZE);</span><br><span class="line">		<span class="keyword">if</span> (stackaddr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			perror(<span class="string">"malloc"</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		stacksize = SIZE;</span><br><span class="line">		pthread_attr_setstack(&amp;attr, stackaddr, stacksize);</span><br><span class="line">		err = pthread_create(&amp;tid, &amp;attr, th_fun, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">if</span> (err != <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, strerror(err));</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i++);</span><br><span class="line">	&#125;</span><br><span class="line">	pthread_attr_destroy(&amp;attr);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>线程使用注意事项</strong></p>
<p>1) 主线程退出其他线程不退出，主线程应调用pthread_exit<br>2) 避免僵尸线程<br>a) pthread_join<br>b) pthread_detach<br>c) pthread_create指定分离属性<br>被join线程可能在join函数返回前就释放完自己的所有内存资源，所以不应当返回被回收线程栈中的值;<br>3) malloc和mmap申请的内存可以被其他线程释放<br>4) 应避免在多线程模型中调用fork，除非马上exec，子进程中只有调用fork的线程存在，其他线程t在子进程中均pthread_exit<br>5) 信号的复杂语义很难和多线程共存，应避免在多线程引入信号机制</p>
<h2 id="11-linux线程间的同步与互斥"><a href="#11-linux线程间的同步与互斥" class="headerlink" title="11 linux线程间的同步与互斥"></a>11 linux线程间的同步与互斥</h2><h3 id="11-1-同步与互斥概述"><a href="#11-1-同步与互斥概述" class="headerlink" title="11.1 同步与互斥概述"></a>11.1 同步与互斥概述</h3><p>现代操作系统基本都是多任务操作系统，即同时有大量可调度实体在运行。在多任务操作系统中，同时运行的多个任务可能：<br>都需要访问/使用同一种资源<br>多个任务之间有依赖关系，某个任务的运行依赖于另一个任务<br>这两种情形是多任务编程中遇到的最基本的问题，也是多任务编程中的核心问题，同步和互斥就是用于解决这两个问题的。<br>互斥：是指散步在不同任务之间的若干程序片断，当某个任务运行其中一个程序片段时，其它任务就不能运行它们之中的任一程序片段，只能等到该任务运行完这个程序片段后才可以运行。最基本的场景就是：一个公共资源同一时刻只能被一个进程或线程使用，多个进程或线程不能同时使用公共资源。</p>
<p>同步：是指散步在不同任务之间的若干程序片断，它们的运行必须严格按照规定的某种先后次序来运行，这种先后次序依赖于要完成的特定的任务。最基本的场景就是：两个或两个以上的进程或线程在运行过程中协同步调，按预定的先后次序运行。比如 A 任务的运行依赖于 B 任务产生的数据。<br>显然，同步是一种更为复杂的互斥，而互斥是一种特殊的同步。也就是说互斥是两个任务之间不可以同时运行，他们会相互排斥，必须等待一个线程运行完毕，另一个才能运行，而同步也是不能同时运行，但他是必须要按照某种次序来运行相应的线程（也是一种互斥）！因此互斥具有唯一性和排它性，但互斥并不限制任务的运行顺序，即任务是无序的，而同步的任务之间则有顺序关系。 </p>
<h3 id="11-2-互斥锁"><a href="#11-2-互斥锁" class="headerlink" title="11.2 互斥锁"></a>11.2 互斥锁</h3><p>互斥锁Mutex介绍<br>而在线程里也有这么一把锁：互斥锁（mutex），也叫互斥量，互斥锁是一种简单的加锁的方法来控制对共享资源的访问，互斥锁只有两种状态,即加锁( lock )和解锁( unlock )。</p>
<p>互斥锁的操作流程如下：<br>1）在访问共享资源后临界区域前，对互斥锁进行加锁。<br>2）在访问完成后释放互斥锁导上的锁。<br>3）对互斥锁进行加锁后，任何其他试图再次对互斥锁加锁的线程将会被阻塞，直到锁被释放。</p>
<p>互斥锁的数据类型是： pthread_mutex_t。</p>
<p>安装对应帮助手册：<br>deng@itcast:~$ sudo apt-get install manpages-posix-dev</p>
<p><strong>互斥锁初始化</strong></p>
<p>pthread_mutex_init 函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;</span><br><span class="line">功能：</span><br><span class="line">    初始化一个互斥锁。</span><br><span class="line">参数：</span><br><span class="line">    mutex：互斥锁地址。类型是 <span class="keyword">pthread_mutex_t</span> 。</span><br><span class="line">    attr：设置互斥量的属性，通常可采用默认属性，即可将 attr 设为 <span class="literal">NULL</span>。</span><br><span class="line">    可以使用宏 PTHREAD_MUTEX_INITIALIZER 静态初始化互斥锁，比如：</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span>  mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line">这种方法等价于使用 <span class="literal">NULL</span> 指定的 attr 参数调用 pthread_mutex_init() 来完成动态初始化，不同之处在于 PTHREAD_MUTEX_INITIALIZER 宏不进行错误检查。</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span>，成功申请的锁默认是打开的。</span><br><span class="line">    失败：非 <span class="number">0</span> 错误码</span><br></pre></td></tr></table></figure>

<blockquote>
<p>restrict，C语言中的一种类型<a href="https://baike.baidu.com/item/限定符/1924249" target="_blank" rel="noopener">限定符</a>（Type Qualifiers），用于告诉编译器，对象已经被指针所引用，不能通过除该指针外所有其他直接或间接的方式修改该对象的内容。</p>
</blockquote>
<p><strong>销毁互斥锁</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line">功能：</span><br><span class="line">    销毁指定的一个互斥锁。互斥锁在使用完毕后，必须要对互斥锁进行销毁，以释放资源。</span><br><span class="line">参数：</span><br><span class="line">    mutex：互斥锁地址。</span><br><span class="line">返回值:</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非 <span class="number">0</span> 错误码</span><br></pre></td></tr></table></figure>

<p><strong>申请上锁</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line">功能：</span><br><span class="line">    对互斥锁上锁，若互斥锁已经上锁，则调用者阻塞，直到互斥锁解锁后再上锁。</span><br><span class="line">参数：</span><br><span class="line">    mutex：互斥锁地址。</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非 <span class="number">0</span> 错误码</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line">   调用该函数时，若互斥锁未加锁，则上锁，返回 <span class="number">0</span>；</span><br><span class="line">   若互斥锁已加锁，则函数直接返回失败，即 EBUSY。</span><br></pre></td></tr></table></figure>

<p><strong>解锁</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line">功能：</span><br><span class="line">    对指定的互斥锁解锁。</span><br><span class="line">参数：</span><br><span class="line">    mutex：互斥锁地址。</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误码</span><br></pre></td></tr></table></figure>

<p>示例代码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//hello</span></span><br><span class="line">	<span class="keyword">while</span>(*str != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">putchar</span>(*str++);</span><br><span class="line">		fflush(<span class="built_in">stdout</span>);</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">pthread_1</span><span class="params">(<span class="keyword">void</span>  *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> buf[]=<span class="string">"hello"</span>;</span><br><span class="line">	pthread_mutex_lock(&amp;mutex);</span><br><span class="line">	<span class="built_in">print</span>(buf);</span><br><span class="line">	pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">pthread_2</span><span class="params">(<span class="keyword">void</span>  *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> buf[]=<span class="string">"world"</span>;</span><br><span class="line"></span><br><span class="line">	pthread_mutex_lock(&amp;mutex);</span><br><span class="line">	<span class="built_in">print</span>(buf);</span><br><span class="line">	pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pthread_mutex_init(&amp;mutex,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">pthread_t</span> pthid[<span class="number">2</span>];</span><br><span class="line">	pthread_create(&amp;pthid[<span class="number">0</span>],<span class="literal">NULL</span>,pthread_1,<span class="literal">NULL</span>);</span><br><span class="line">	pthread_create(&amp;pthid[<span class="number">1</span>],<span class="literal">NULL</span>,pthread_2,<span class="literal">NULL</span>);</span><br><span class="line">	pthread_join(pthid[<span class="number">0</span>],<span class="literal">NULL</span>);</span><br><span class="line">	pthread_join(pthid[<span class="number">1</span>],<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-3-死锁"><a href="#11-3-死锁" class="headerlink" title="11.3 死锁"></a>11.3 死锁</h3><p>互斥条件<br>某资源只能被一个进程使用，其他进程请求该资源时，只能等待，直到资源使用完毕后释放资源。<br>请求和保持条件<br>程序已经保持了至少一个资源，但是又提出了新要求，而这个资源被其他进程占用，自己占用资源却保持不放。<br>不可抢占条件<br>进程已获得的资源没有使用完，不能被抢占。<br>循环等待条件<br>必然存在一个循环链。<br>4）处理死锁的思路<br>预防死锁<br>破坏死锁的四个必要条件中的一个或多个来预防死锁。<br>避免死锁<br>和预防死锁的区别就是，在资源动态分配过程中，用某种方式防止系统进入不安全的状态。<br>检测死锁<br>运行时出现死锁，能及时发现死锁，把程序解脱出来<br>解除死锁<br>发生死锁后，解脱进程，通常撤销进程，回收资源，再分配给正处于阻塞状态的进程。<br>5）预防死锁的方法<br>破坏请求和保持条件<br>协议1：<br>所有进程开始前，必须一次性地申请所需的所有资源，这样运行期间就不会再提出资源要求，破坏了请求条件，即使有一种资源不能满足需求，也不会给它分配正在空闲的资源，这样它就没有资源，就破坏了保持条件，从而预防死锁的发生。<br>协议2：<br>允许一个进程只获得初期的资源就开始运行，然后再把运行完的资源释放出来。然后再请求新的资源。<br>破坏不可抢占条件<br>当一个已经保持了某种不可抢占资源的进程，提出新资源请求不能被满足时，它必须释放已经保持的所有资源，以后需要时再重新申请。<br>破坏循环等待条件<br>对系统中的所有资源类型进行线性排序，然后规定每个进程必须按序列号递增的顺序请求资源。假如进程请求到了一些序列号较高的资源，然后有请求一个序列较低的资源时，必须先释放相同和更高序号的资源后才能申请低序号的资源。多个同类资源必须一起请求。</p>
<h3 id="11-4-读写锁"><a href="#11-4-读写锁" class="headerlink" title="11.4 读写锁"></a>11.4 读写锁</h3><p><strong>读写锁概述</strong></p>
<p>当有一个线程已经持有互斥锁时，互斥锁将所有试图进入临界区的线程都阻塞住。但是考虑一种情形，当前持有互斥锁的线程只是要读访问共享资源，而同时有其它几个线程也想读取这个共享资源，但是由于互斥锁的排它性，所有其它线程都无法获取锁，也就无法读访问共享资源了，但是实际上多个线程同时读访问共享资源并不会导致问题。<br>在对数据的读写操作中，更多的是读操作，写操作较少，例如对数据库数据的读写应用。为了满足当前能够允许多个读出，但只允许一个写入的需求，线程提供了读写锁来实现。</p>
<p>读写锁的特点如下：<br>1）如果有其它线程读数据，则允许其它线程执行读操作，但不允许写操作。<br>2）如果有其它线程写数据，则其它线程都不允许读、写操作。</p>
<p>读写锁分为读锁和写锁，规则如下：<br>1）如果某线程申请了读锁，其它线程可以再申请读锁，但不能申请写锁。<br>2）如果某线程申请了写锁，其它线程不能申请读锁，也不能申请写锁。</p>
<p>POSIX 定义的读写锁的数据类型是： pthread_rwlock_t。</p>
<p><strong>初始化读写锁</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1#include &lt;pthread.h&gt;</span><br><span class="line">int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock,</span><br><span class="line">    const pthread_rwlockattr_t *restrict attr);</span><br><span class="line">功能：</span><br><span class="line">    用来初始化 rwlock 所指向的读写锁。</span><br><span class="line">参数：</span><br><span class="line">    rwlock：指向要初始化的读写锁指针。</span><br><span class="line">    attr：读写锁的属性指针。如果 attr 为 NULL 则会使用默认的属性初始化读写锁，否则使用指定的 attr 初始化读写锁。</span><br><span class="line">  	可以使用宏 PTHREAD_RWLOCK_INITIALIZER 静态初始化读写锁，比如：</span><br><span class="line">    pthread_rwlock_t my_rwlock = PTHREAD_RWLOCK_INITIALIZER;</span><br><span class="line">    这种方法等价于使用 NULL 指定的 attr 参数调用 pthread_rwlock_init() 来完成动态初始化，不同之处在于PTHREAD_RWLOCK_INITIALIZER 宏不进行错误检查。</span><br><span class="line">返回值：</span><br><span class="line">    成功：0，读写锁的状态将成为已初始化和已解锁。</span><br><span class="line">    失败：非 0 错误码。</span><br></pre></td></tr></table></figure>

<p><strong>释放读写锁</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_destroy</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line">功能：</span><br><span class="line">    用于销毁一个读写锁，并释放所有相关联的资源（所谓的所有指的是由 pthread_rwlock_init() 自动申请的资源） 。</span><br><span class="line">参数：</span><br><span class="line">    rwlock：读写锁指针。</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非 <span class="number">0</span> 错误码</span><br></pre></td></tr></table></figure>

<p><strong>申请读锁</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_rdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line">功能：</span><br><span class="line">    以阻塞方式在读写锁上获取读锁（读锁定）。</span><br><span class="line">    如果没有写者持有该锁，并且没有写者阻塞在该锁上，则调用线程会获取读锁。</span><br><span class="line">    如果调用线程未获取读锁，则它将阻塞直到它获取了该锁。一个线程可以在一个读写锁上多次执行读锁定。</span><br><span class="line">    线程可以成功调用 pthread_rwlock_rdlock() 函数 n 次，但是之后该线程必须调用 pthread_rwlock_unlock() 函数 n 次才能解除锁定。</span><br><span class="line">参数：</span><br><span class="line">    rwlock：读写锁指针。</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非 <span class="number">0</span> 错误码</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_tryrdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line">    用于尝试以非阻塞的方式来在读写锁上获取读锁。</span><br><span class="line"> </span><br><span class="line">    如果有任何的写者持有该锁或有写者阻塞在该读写锁上，则立即失败返回。</span><br></pre></td></tr></table></figure>

<p><strong>申请写锁</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_wrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line">功能：</span><br><span class="line">    在读写锁上获取写锁（写锁定）。</span><br><span class="line">    如果没有写者持有该锁，并且没有写者读者持有该锁，则调用线程会获取写锁。</span><br><span class="line">    如果调用线程未获取写锁，则它将阻塞直到它获取了该锁。</span><br><span class="line">参数：</span><br><span class="line">    rwlock：读写锁指针。</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非 <span class="number">0</span> 错误码</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_trywrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line">  用于尝试以非阻塞的方式来在读写锁上获取写锁。</span><br><span class="line"></span><br><span class="line">  如果有任何的读者或写者持有该锁，则立即失败返回。</span><br></pre></td></tr></table></figure>

<p><strong>释放读写锁</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_unlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line">功能：</span><br><span class="line">    无论是读锁或写锁，都可以通过此函数解锁。</span><br><span class="line">参数：</span><br><span class="line">    rwlock：读写锁指针。</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非 <span class="number">0</span> 错误码</span><br></pre></td></tr></table></figure>

<p>示例代码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">pthread_rwlock_t</span> rwlock;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">read_cb</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		pthread_rwlock_rdlock(&amp;rwlock);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s %lu  %d\n"</span>,__FUNCTION__,pthread_self(),num);</span><br><span class="line">		pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">write_cb</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		pthread_rwlock_wrlock(&amp;rwlock);</span><br><span class="line">		num++;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s %lu  %d\n"</span>,__FUNCTION__,pthread_self(),num);</span><br><span class="line">		</span><br><span class="line">		pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pthread_rwlock_init(&amp;rwlock,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">pthread_t</span> pthid[<span class="number">8</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;<span class="number">5</span>)<span class="comment">//创建读线程</span></span><br><span class="line">		&#123;</span><br><span class="line">			pthread_create(&amp;pthid[i],<span class="literal">NULL</span>,read_cb,<span class="literal">NULL</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span><span class="comment">//创建写线程</span></span><br><span class="line">		&#123;</span><br><span class="line">			pthread_create(&amp;pthid[i],<span class="literal">NULL</span>,write_cb,<span class="literal">NULL</span>);</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		pthread_join(pthid[i],<span class="literal">NULL</span>);</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	pthread_rwlock_destroy(&amp;rwlock);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="11-5-条件变量"><a href="#11-5-条件变量" class="headerlink" title="11.5 条件变量"></a>11.5 条件变量</h3><p>与互斥锁不同，条件变量是用来等待而不是用来上锁的，条件变量本身不是锁！<br>条件变量用来自动阻塞一个线程，直到某特殊情况发生为止。通常条件变量和互斥锁同时使用。<br>条件变量的两个动作：<br>条件不满, 阻塞线程<br>当条件满足, 通知阻塞的线程开始工作<br>条件变量的类型: pthread_cond_t。</p>
<p><strong>条件变量初始化</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;</span><br><span class="line">功能：</span><br><span class="line">    初始化一个条件变量</span><br><span class="line">参数：</span><br><span class="line">    cond：指向要初始化的条件变量指针。</span><br><span class="line">    attr：条件变量属性，通常为默认值，传<span class="literal">NULL</span>即可</span><br><span class="line">        也可以使用静态初始化的方法，初始化条件变量：</span><br><span class="line">        <span class="keyword">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误号</span><br></pre></td></tr></table></figure>

<p><strong>释放条件变量</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line">功能：</span><br><span class="line">    销毁一个条件变量</span><br><span class="line">参数：</span><br><span class="line">    cond：指向要初始化的条件变量指针</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误号</span><br></pre></td></tr></table></figure>

<p><strong>等待条件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">int pthread_cond_wait(pthread_cond_t *restrict cond,</span><br><span class="line">    pthread_mutex_t *restrict mutex);</span><br><span class="line">功能：</span><br><span class="line">    阻塞等待一个条件变量</span><br><span class="line">    a) 阻塞等待条件变量cond（参1）满足</span><br><span class="line">    b) 释放已掌握的互斥锁（解锁互斥量）相当于pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">            a) b) 两步为一个原子操作。</span><br><span class="line">    c) 当被唤醒，pthread_cond_wait函数返回时，解除阻塞并重新申请获取互斥锁pthread_mutex_lock(&amp;mutex);</span><br><span class="line">参数：</span><br><span class="line">    cond：指向要初始化的条件变量指针</span><br><span class="line">    mutex：互斥锁</span><br><span class="line">返回值：</span><br><span class="line">    成功：0</span><br><span class="line">    失败：非0错误号</span><br><span class="line">int pthread_cond_timedwait(pthread_cond_t *restrict cond,</span><br><span class="line">    pthread_mutex_t *restrict mutex,</span><br><span class="line">    const struct</span><br><span class="line">                           .*restrict abstime);</span><br><span class="line">功能：</span><br><span class="line">    限时等待一个条件变量</span><br><span class="line">参数：</span><br><span class="line">    cond：指向要初始化的条件变量指针</span><br><span class="line">    mutex：互斥锁</span><br><span class="line">    abstime：绝对时间</span><br><span class="line">返回值：</span><br><span class="line">    成功：0</span><br><span class="line">    失败：非0错误号</span><br></pre></td></tr></table></figure>

<p><strong>唤醒等待在条件变量上的线程</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line">功能：</span><br><span class="line">    唤醒至少一个阻塞在条件变量上的线程</span><br><span class="line">参数</span><br><span class="line">    cond：指向要初始化的条件变量指</span><br><span class="line">返回值</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误号</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line">功能：</span><br><span class="line">    唤醒全部阻塞在条件变量上的线程</span><br><span class="line">参数：</span><br><span class="line">    cond：指向要初始化的条件变量指针</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：非<span class="number">0</span>错误号</span><br></pre></td></tr></table></figure>

<p>int pthread_cond_broadcast(pthread_cond_t *cond);<br>功能: 给阻塞在条件变量上的所有线程发送信号<br>参数: cond 条件变量的地址</p>
<p>条件变量实现生产者与消费者代码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ************************************************************************</span></span><br><span class="line"><span class="comment">*       Filename:  08_pthread_cond.c</span></span><br><span class="line"><span class="comment">*    Description:  </span></span><br><span class="line"><span class="comment">*        Version:  1.0</span></span><br><span class="line"><span class="comment">*        Created:  2019年06月11日 15时54分24秒</span></span><br><span class="line"><span class="comment">*       Revision:  none</span></span><br><span class="line"><span class="comment">*       Compiler:  gcc</span></span><br><span class="line"><span class="comment">*         Author:  YOUR NAME (),</span></span><br><span class="line"><span class="comment">*        Company:  </span></span><br><span class="line"><span class="comment">* ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="keyword">pthread_cond_t</span> cond;</span><br><span class="line"><span class="comment">//定义饼的结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cake</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cake</span>*<span class="title">next</span>;</span></span><br><span class="line">&#125;CAKE;</span><br><span class="line">CAKE *head=<span class="literal">NULL</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producer</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> beginnum=<span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(rand()%<span class="number">3</span>);<span class="comment">//生产延时</span></span><br><span class="line">        <span class="comment">//生产</span></span><br><span class="line">        CAKE*info = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(CAKE));</span><br><span class="line">        info-&gt;num = beginnum++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对饼框操作 放 取 都要互斥 加锁</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">//放饼  对链表头插</span></span><br><span class="line">        info-&gt;next = head;</span><br><span class="line">        head = info;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s %lu %d\n"</span>,__FUNCTION__,pthread_self(),info-&gt;num);</span><br><span class="line">        pthread_cond_broadcast(&amp;cond);<span class="comment">//通知所有等待在条件上的线程</span></span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">//判断有没有饼</span></span><br><span class="line">        <span class="keyword">while</span>( head ==  <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_cond_wait(&amp;cond,&amp;mutex);<span class="comment">//解锁 等待条件 条件满足抢锁</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        CAKE *info = head;<span class="comment">//取饼</span></span><br><span class="line">        head = head-&gt;next;<span class="comment">//取饼</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s %lu %d\n"</span>,__FUNCTION__,pthread_self(),info-&gt;num);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        sleep(rand()%<span class="number">3</span>);<span class="comment">//消费延时</span></span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pthread_mutex_init(&amp;mutex,<span class="literal">NULL</span>);<span class="comment">//初始化互斥锁</span></span><br><span class="line">    pthread_cond_init(&amp;cond,<span class="literal">NULL</span>);<span class="comment">//初始化条件变量</span></span><br><span class="line">    <span class="keyword">pthread_t</span> pthid[<span class="number">3</span>];</span><br><span class="line">    pthread_create(&amp;pthid[<span class="number">0</span>],<span class="literal">NULL</span>,producer,<span class="literal">NULL</span>);<span class="comment">//生产者线程</span></span><br><span class="line">    pthread_create(&amp;pthid[<span class="number">1</span>],<span class="literal">NULL</span>,consumer,<span class="literal">NULL</span>);<span class="comment">//消费者线程</span></span><br><span class="line">    pthread_create(&amp;pthid[<span class="number">2</span>],<span class="literal">NULL</span>,consumer,<span class="literal">NULL</span>);<span class="comment">//消费者线程</span></span><br><span class="line">    pthread_join(pthid[<span class="number">0</span>],<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(pthid[<span class="number">1</span>],<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(pthid[<span class="number">2</span>],<span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    pthread_cond_destroy(&amp;cond);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="11-6-信号量"><a href="#11-6-信号量" class="headerlink" title="11.6 信号量"></a>11.6 信号量</h3><p>信号量概述<br>信号量广泛用于进程或线程间的同步和互斥，信号量本质上是一个非负的整数计数器，它被用来控制对公共资源的访问。<br>编程时可根据操作信号量值的结果判断是否对公共资源具有访问的权限，当信号量值大于 0 时，则可以访问，否则将阻塞。<br>PV 原语是对信号量的操作，一次 P 操作使信号量减１，一次 V 操作使信号量加１。<br>信号量主要用于进程或线程间的同步和互斥这两种典型情况。<br>信号量数据类型为：sem_t。</p>
<p>信号量用于互斥：</p>
<p><img src="/2019/11/03/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/assets%5C1562242560834.png" alt="1562242560834"></p>
<p>信号量用于同步:</p>
<p><img src="/2019/11/03/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/assets%5C1562242592554.png" alt="1562242592554"></p>
<p><strong>初始化信号量:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_init</span><span class="params">(<span class="keyword">sem_t</span> *sem, <span class="keyword">int</span> pshared, <span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span></span><br><span class="line">功能：</span><br><span class="line">    创建一个信号量并初始化它的值。一个无名信号量在被使用前必须先初始化。</span><br><span class="line">参数：</span><br><span class="line">    sem：信号量的地址</span><br><span class="line">    pshared：等于 <span class="number">0</span>，信号量在线程间共享（常用）；不等于<span class="number">0</span>，信号量在进程间共享。</span><br><span class="line">    value：信号量的初始值</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败： - <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>信号量减一</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_wait</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line">功能: 将信号量减一,如果信号量的值为<span class="number">0</span> 则阻塞,大于<span class="number">0</span>可以减一</span><br><span class="line"> 参数:信号量的地址 </span><br><span class="line"> 返回值:成功返回<span class="number">0</span> 失败返回<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p><strong>尝试对信号量减一</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_trywait</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line">功能: 尝试将信号量减一,如果信号量的值为<span class="number">0</span> 不阻塞,立即返回 ,大于<span class="number">0</span>可以减一</span><br><span class="line">参数:信号量的地址 </span><br><span class="line">返回值:成功返回<span class="number">0</span> 失败返回<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p><strong>信号量加一</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_post</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line">功能:将信号量加一</span><br><span class="line">参数:信号量的地址 </span><br><span class="line">返回值:成功返回<span class="number">0</span> 失败返回<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p><strong>销毁信号量</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_destroy</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line">功能: 销毁信号量</span><br><span class="line">参数: 信号量的地址</span><br><span class="line">返回值:成功返回<span class="number">0</span> 失败返回<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>信号量实现同步代码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> ch=<span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">sem_t</span> sem1,sem2;</span><br><span class="line"><span class="function"><span class="keyword">void</span>*<span class="title">pth_fun1</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		sem_wait(&amp;sem2);</span><br><span class="line">		ch++;</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">		sem_post(&amp;sem1);</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">pth_fun2</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		sem_wait(&amp;sem1);</span><br><span class="line">		<span class="built_in">putchar</span>(ch);</span><br><span class="line">		fflush(<span class="built_in">stdout</span>);</span><br><span class="line">		sem_post(&amp;sem2);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	sem_init(&amp;sem1,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">	sem_init(&amp;sem2,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">pthread_t</span> pthid[<span class="number">2</span>];</span><br><span class="line">	pthread_create(&amp;pthid[<span class="number">0</span>],<span class="literal">NULL</span>,pth_fun1,<span class="literal">NULL</span>);</span><br><span class="line">	pthread_create(&amp;pthid[<span class="number">1</span>],<span class="literal">NULL</span>,pth_fun2,<span class="literal">NULL</span>);</span><br><span class="line">	pthread_join(pthid[<span class="number">0</span>],<span class="literal">NULL</span>);</span><br><span class="line">	pthread_join(pthid[<span class="number">1</span>],<span class="literal">NULL</span>);</span><br><span class="line">	sem_destroy(&amp;sem1);</span><br><span class="line">	sem_destroy(&amp;sem2);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>作业: 用信号量实现生产者与消费者模型</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/11/03/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/" data-id="ck2pgsnk1000338ue5l9582f7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/03/hello-world/" class="article-date">
  <time datetime="2019-11-03T04:30:02.456Z" itemprop="datePublished">2019-11-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/03/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/11/03/hello-world/" data-id="ck2pgsniz000138uebc8rhkyj" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/11/08/w're'r'q'er/">w&#39;re&#39;r&#39;q&#39;er</a>
          </li>
        
          <li>
            <a href="/2019/11/04/heihie/">heihie</a>
          </li>
        
          <li>
            <a href="/2019/11/03/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/">linux系统编程</a>
          </li>
        
          <li>
            <a href="/2019/11/03/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>